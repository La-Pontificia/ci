"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/Draggable.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/Draggable.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n    enumerable: true,\n    get: function() {\n        return _DraggableCore.default;\n    }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.0.5-canary.58_@babel+core@7.9.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@14.0.5-canary.58_@babel+core@7.9.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/.pnpm/clsx@1.2.1/node_modules/clsx/dist/clsx.m.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ \n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/ /*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/ /*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/ //\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {\n    // React 16.3+\n    // Arity (props, state)\n    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {\n        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;\n        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;\n        // Set x/y if a new position is provided in props that is different than the previous.\n        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n            (0, _log.default)(\"Draggable: getDerivedStateFromProps %j\", {\n                position,\n                prevPropsPosition\n            });\n            return {\n                x: position.x,\n                y: position.y,\n                prevPropsPosition: {\n                    ...position\n                }\n            };\n        }\n        return null;\n    }\n    constructor(props /*: DraggableProps*/ ){\n        super(props);\n        _defineProperty(this, \"onDragStart\", (e, coreData)=>{\n            (0, _log.default)(\"Draggable: onDragStart: %j\", coreData);\n            // Short-circuit if user's callback killed it.\n            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n            // Kills start event on core as well, so move handlers are never bound.\n            if (shouldStart === false) return false;\n            this.setState({\n                dragging: true,\n                dragged: true\n            });\n        });\n        _defineProperty(this, \"onDrag\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            (0, _log.default)(\"Draggable: onDrag: %j\", coreData);\n            const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n            const newState = {\n                x: uiData.x,\n                y: uiData.y,\n                slackX: 0,\n                slackY: 0\n            };\n            // Keep within bounds.\n            if (this.props.bounds) {\n                // Save original x and y.\n                const { x, y } = newState;\n                // Add slack to the values used to calculate bound position. This will ensure that if\n                // we start removing slack, the element won't react to it right away until it's been\n                // completely removed.\n                newState.x += this.state.slackX;\n                newState.y += this.state.slackY;\n                // Get bound position. This will ceil/floor the x and y within the boundaries.\n                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n                newState.x = newStateX;\n                newState.y = newStateY;\n                // Recalculate slack by noting how much was shaved by the boundPosition handler.\n                newState.slackX = this.state.slackX + (x - newState.x);\n                newState.slackY = this.state.slackY + (y - newState.y);\n                // Update the event we fire to reflect what really happened after bounds took effect.\n                uiData.x = newState.x;\n                uiData.y = newState.y;\n                uiData.deltaX = newState.x - this.state.x;\n                uiData.deltaY = newState.y - this.state.y;\n            }\n            // Short-circuit if user's callback killed it.\n            const shouldUpdate = this.props.onDrag(e, uiData);\n            if (shouldUpdate === false) return false;\n            this.setState(newState);\n        });\n        _defineProperty(this, \"onDragStop\", (e, coreData)=>{\n            if (!this.state.dragging) return false;\n            // Short-circuit if user's callback killed it.\n            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n            if (shouldContinue === false) return false;\n            (0, _log.default)(\"Draggable: onDragStop: %j\", coreData);\n            const newState /*: Partial<DraggableState>*/  = {\n                dragging: false,\n                slackX: 0,\n                slackY: 0\n            };\n            // If this is a controlled component, the result of this operation will be to\n            // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n            const controlled = Boolean(this.props.position);\n            if (controlled) {\n                const { x, y } = this.props.position;\n                newState.x = x;\n                newState.y = y;\n            }\n            this.setState(newState);\n        });\n        this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            x: props.position ? props.position.x : props.defaultPosition.x,\n            y: props.position ? props.position.y : props.defaultPosition.y,\n            prevPropsPosition: {\n                ...props.position\n            },\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n        };\n        if (props.position && !(props.onDrag || props.onStop)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"A `position` was applied to this <Draggable>, without drag handlers. This will make this \" + \"component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the \" + \"`position` of this element.\");\n        }\n    }\n    componentDidMount() {\n        // Check to see if the element passed is an instanceof SVGElement\n        if (typeof window.SVGElement !== \"undefined\" && this.findDOMNode() instanceof window.SVGElement) {\n            this.setState({\n                isElementSVG: true\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.setState({\n            dragging: false\n        }); // prevents invariant if unmounted while dragging\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        var _this$props$nodeRef$c, _this$props;\n        return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: ReactElement<any>*/ {\n        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;\n        let style = {};\n        let svgTransform = null;\n        // If this is controlled, we don't want to move it - unless it's dragging.\n        const controlled = Boolean(position);\n        const draggable = !controlled || this.state.dragging;\n        const validPosition = position || defaultPosition;\n        const transformOpts = {\n            // Set left if horizontal drag is enabled\n            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n            // Set top if vertical drag is enabled\n            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n        };\n        // If this element was SVG, we use the `transform` attribute.\n        if (this.state.isElementSVG) {\n            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n        } else {\n            // Add a CSS transform to move the element around. This allows us to move the element around\n            // without worrying about whether or not it is relatively or absolutely positioned.\n            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n            // has a clean slate.\n            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n        }\n        // Mark with class while dragging\n        const className = (0, _clsx.default)(children.props.className || \"\", defaultClassName, {\n            [defaultClassNameDragging]: this.state.dragging,\n            [defaultClassNameDragged]: this.state.dragged\n        });\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n            onStart: this.onDragStart,\n            onDrag: this.onDrag,\n            onStop: this.onDragStop\n        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {\n            className: className,\n            style: {\n                ...children.props.style,\n                ...style\n            },\n            transform: svgTransform\n        }));\n    }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", \"Draggable\");\n_defineProperty(Draggable, \"propTypes\", {\n    // Accepts all props <DraggableCore> accepts.\n    ..._DraggableCore.default.propTypes,\n    /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */ axis: _propTypes.default.oneOf([\n        \"both\",\n        \"x\",\n        \"y\",\n        \"none\"\n    ]),\n    /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ bounds: _propTypes.default.oneOfType([\n        _propTypes.default.shape({\n            left: _propTypes.default.number,\n            right: _propTypes.default.number,\n            top: _propTypes.default.number,\n            bottom: _propTypes.default.number\n        }),\n        _propTypes.default.string,\n        _propTypes.default.oneOf([\n            false\n        ])\n    ]),\n    defaultClassName: _propTypes.default.string,\n    defaultClassNameDragging: _propTypes.default.string,\n    defaultClassNameDragged: _propTypes.default.string,\n    /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ defaultPosition: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    positionOffset: _propTypes.default.shape({\n        x: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ]),\n        y: _propTypes.default.oneOfType([\n            _propTypes.default.number,\n            _propTypes.default.string\n        ])\n    }),\n    /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */ position: _propTypes.default.shape({\n        x: _propTypes.default.number,\n        y: _propTypes.default.number\n    }),\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n    ..._DraggableCore.default.defaultProps,\n    axis: \"both\",\n    bounds: false,\n    defaultClassName: \"react-draggable\",\n    defaultClassNameDragging: \"react-draggable-dragging\",\n    defaultClassNameDragged: \"react-draggable-dragged\",\n    defaultPosition: {\n        x: 0,\n        y: 0\n    },\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDSCxPQUFPQyxlQUFlQyxPQUFPO0lBQy9CO0FBQ0YsQ0FBQyxFQUFDO0FBQ0ZMLGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJTSxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLGlNQUFPO0FBQ25ELElBQUlDLGFBQWFDLHVCQUF1QkYsbUJBQU9BLENBQUMsaUdBQVk7QUFDNUQsSUFBSUcsWUFBWUQsdUJBQXVCRixtQkFBT0EsQ0FBQyx5TUFBVztBQUMxRCxJQUFJSSxRQUFRRix1QkFBdUJGLG1CQUFPQSxDQUFDLG9GQUFNO0FBQ2pELElBQUlLLFVBQVVMLG1CQUFPQSxDQUFDLDZKQUFnQjtBQUN0QyxJQUFJTSxlQUFlTixtQkFBT0EsQ0FBQyx1S0FBcUI7QUFDaEQsSUFBSU8sU0FBU1AsbUJBQU9BLENBQUMsMkpBQWU7QUFDcEMsSUFBSUosaUJBQWlCTSx1QkFBdUJGLG1CQUFPQSxDQUFDLCtKQUFpQjtBQUNyRSxJQUFJUSxPQUFPTix1QkFBdUJGLG1CQUFPQSxDQUFDLHVKQUFhO0FBQ3ZELFNBQVNFLHVCQUF1Qk8sR0FBRztJQUFJLE9BQU9BLE9BQU9BLElBQUlDLFVBQVUsR0FBR0QsTUFBTTtRQUFFWixTQUFTWTtJQUFJO0FBQUc7QUFDOUYsU0FBU0UseUJBQXlCQyxXQUFXO0lBQUksSUFBSSxPQUFPQyxZQUFZLFlBQVksT0FBTztJQUFNLElBQUlDLG9CQUFvQixJQUFJRDtJQUFXLElBQUlFLG1CQUFtQixJQUFJRjtJQUFXLE9BQU8sQ0FBQ0YsMkJBQTJC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QVMsQ0FBQztZQUFDaEksV0FBV0osT0FBTyxDQUFDdUksTUFBTTtZQUFFbkksV0FBV0osT0FBTyxDQUFDMkksTUFBTTtTQUFDO1FBQ3RGNUUsR0FBRzNELFdBQVdKLE9BQU8sQ0FBQ29JLFNBQVMsQ0FBQztZQUFDaEksV0FBV0osT0FBTyxDQUFDdUksTUFBTTtZQUFFbkksV0FBV0osT0FBTyxDQUFDMkksTUFBTTtTQUFDO0lBQ3hGO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkMsR0FDRC9FLFVBQVV4RCxXQUFXSixPQUFPLENBQUNxSSxLQUFLLENBQUM7UUFDakN2RSxHQUFHMUQsV0FBV0osT0FBTyxDQUFDdUksTUFBTTtRQUM1QnhFLEdBQUczRCxXQUFXSixPQUFPLENBQUN1SSxNQUFNO0lBQzlCO0lBQ0E7O0dBRUMsR0FDRGIsV0FBV2hILE9BQU9rSSxTQUFTO0lBQzNCM0IsT0FBT3ZHLE9BQU9rSSxTQUFTO0lBQ3ZCWCxXQUFXdkgsT0FBT2tJLFNBQVM7QUFDN0I7QUFDQXJHLGdCQUFnQmdCLFdBQVcsZ0JBQWdCO0lBQ3pDLEdBQUd4RCxlQUFlQyxPQUFPLENBQUM2SSxZQUFZO0lBQ3RDcEMsTUFBTTtJQUNOMUIsUUFBUTtJQUNSNEIsa0JBQWtCO0lBQ2xCQywwQkFBMEI7SUFDMUJDLHlCQUF5QjtJQUN6QmxCLGlCQUFpQjtRQUNmN0IsR0FBRztRQUNIQyxHQUFHO0lBQ0w7SUFDQWdELE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjQuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGUuanM/MzFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRyYWdnYWJsZUNvcmVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX0RyYWdnYWJsZUNvcmUuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX2RvbUZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL2RvbUZuc1wiKTtcbnZhciBfcG9zaXRpb25GbnMgPSByZXF1aXJlKFwiLi91dGlscy9wb3NpdGlvbkZuc1wiKTtcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi91dGlscy9zaGltc1wiKTtcbnZhciBfRHJhZ2dhYmxlQ29yZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRHJhZ2dhYmxlQ29yZVwiKSk7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfSAvKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVDb3JlUHJvcHMsIERyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHN9IGZyb20gJy4vRHJhZ2dhYmxlQ29yZSc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgRHJhZ2dhYmxlRXZlbnRIYW5kbGVyfSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLyo6OiB0eXBlIERyYWdnYWJsZVN0YXRlID0ge1xuICBkcmFnZ2luZzogYm9vbGVhbixcbiAgZHJhZ2dlZDogYm9vbGVhbixcbiAgeDogbnVtYmVyLCB5OiBudW1iZXIsXG4gIHNsYWNrWDogbnVtYmVyLCBzbGFja1k6IG51bWJlcixcbiAgaXNFbGVtZW50U1ZHOiBib29sZWFuLFxuICBwcmV2UHJvcHNQb3NpdGlvbjogP0NvbnRyb2xQb3NpdGlvbixcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlRGVmYXVsdFByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlRGVmYXVsdFByb3BzLFxuICBheGlzOiAnYm90aCcgfCAneCcgfCAneScgfCAnbm9uZScsXG4gIGJvdW5kczogQm91bmRzIHwgc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRDbGFzc05hbWU6IHN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiBzdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBzdHJpbmcsXG4gIGRlZmF1bHRQb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVQcm9wcyA9IHtcbiAgLi4uRHJhZ2dhYmxlQ29yZVByb3BzLFxuICAuLi5EcmFnZ2FibGVEZWZhdWx0UHJvcHMsXG4gIHBvc2l0aW9uT2Zmc2V0OiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbixcbiAgcG9zaXRpb246IENvbnRyb2xQb3NpdGlvbixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZT5cbi8vXG5jbGFzcyBEcmFnZ2FibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlUHJvcHMsIERyYWdnYWJsZVN0YXRlPiove1xuICAvLyBSZWFjdCAxNi4zK1xuICAvLyBBcml0eSAocHJvcHMsIHN0YXRlKVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKF9yZWYgLyo6OiAqLywgX3JlZjIgLyo6OiAqLykgLyo6ID9QYXJ0aWFsPERyYWdnYWJsZVN0YXRlPiove1xuICAgIGxldCB7XG4gICAgICBwb3NpdGlvblxuICAgIH0gLyo6IERyYWdnYWJsZVByb3BzKi8gPSBfcmVmIC8qOiBEcmFnZ2FibGVQcm9wcyovO1xuICAgIGxldCB7XG4gICAgICBwcmV2UHJvcHNQb3NpdGlvblxuICAgIH0gLyo6IERyYWdnYWJsZVN0YXRlKi8gPSBfcmVmMiAvKjogRHJhZ2dhYmxlU3RhdGUqLztcbiAgICAvLyBTZXQgeC95IGlmIGEgbmV3IHBvc2l0aW9uIGlzIHByb3ZpZGVkIGluIHByb3BzIHRoYXQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzLlxuICAgIGlmIChwb3NpdGlvbiAmJiAoIXByZXZQcm9wc1Bvc2l0aW9uIHx8IHBvc2l0aW9uLnggIT09IHByZXZQcm9wc1Bvc2l0aW9uLnggfHwgcG9zaXRpb24ueSAhPT0gcHJldlByb3BzUG9zaXRpb24ueSkpIHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAlaicsIHtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHByZXZQcm9wc1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICAgIHByZXZQcm9wc1Bvc2l0aW9uOiB7XG4gICAgICAgICAgLi4ucG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IocHJvcHMgLyo6IERyYWdnYWJsZVByb3BzKi8pIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RhcnRcIiwgKGUsIGNvcmVEYXRhKSA9PiB7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWdTdGFydDogJWonLCBjb3JlRGF0YSk7XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZFN0YXJ0ID0gdGhpcy5wcm9wcy5vblN0YXJ0KGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpKTtcbiAgICAgIC8vIEtpbGxzIHN0YXJ0IGV2ZW50IG9uIGNvcmUgYXMgd2VsbCwgc28gbW92ZSBoYW5kbGVycyBhcmUgbmV2ZXIgYm91bmQuXG4gICAgICBpZiAoc2hvdWxkU3RhcnQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ2dpbmc6IHRydWUsXG4gICAgICAgIGRyYWdnZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogb25EcmFnOiAlaicsIGNvcmVEYXRhKTtcbiAgICAgIGNvbnN0IHVpRGF0YSA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgIHg6IHVpRGF0YS54LFxuICAgICAgICB5OiB1aURhdGEueSxcbiAgICAgICAgc2xhY2tYOiAwLFxuICAgICAgICBzbGFja1k6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIEtlZXAgd2l0aGluIGJvdW5kcy5cbiAgICAgIGlmICh0aGlzLnByb3BzLmJvdW5kcykge1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIHggYW5kIHkuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IG5ld1N0YXRlO1xuXG4gICAgICAgIC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAgICAgLy8gd2Ugc3RhcnQgcmVtb3Zpbmcgc2xhY2ssIHRoZSBlbGVtZW50IHdvbid0IHJlYWN0IHRvIGl0IHJpZ2h0IGF3YXkgdW50aWwgaXQncyBiZWVuXG4gICAgICAgIC8vIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgICAgICAgbmV3U3RhdGUueCArPSB0aGlzLnN0YXRlLnNsYWNrWDtcbiAgICAgICAgbmV3U3RhdGUueSArPSB0aGlzLnN0YXRlLnNsYWNrWTtcblxuICAgICAgICAvLyBHZXQgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBjZWlsL2Zsb29yIHRoZSB4IGFuZCB5IHdpdGhpbiB0aGUgYm91bmRhcmllcy5cbiAgICAgICAgY29uc3QgW25ld1N0YXRlWCwgbmV3U3RhdGVZXSA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Qm91bmRQb3NpdGlvbikodGhpcywgbmV3U3RhdGUueCwgbmV3U3RhdGUueSk7XG4gICAgICAgIG5ld1N0YXRlLnggPSBuZXdTdGF0ZVg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSBuZXdTdGF0ZVk7XG5cbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgc2xhY2sgYnkgbm90aW5nIGhvdyBtdWNoIHdhcyBzaGF2ZWQgYnkgdGhlIGJvdW5kUG9zaXRpb24gaGFuZGxlci5cbiAgICAgICAgbmV3U3RhdGUuc2xhY2tYID0gdGhpcy5zdGF0ZS5zbGFja1ggKyAoeCAtIG5ld1N0YXRlLngpO1xuICAgICAgICBuZXdTdGF0ZS5zbGFja1kgPSB0aGlzLnN0YXRlLnNsYWNrWSArICh5IC0gbmV3U3RhdGUueSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBldmVudCB3ZSBmaXJlIHRvIHJlZmxlY3Qgd2hhdCByZWFsbHkgaGFwcGVuZWQgYWZ0ZXIgYm91bmRzIHRvb2sgZWZmZWN0LlxuICAgICAgICB1aURhdGEueCA9IG5ld1N0YXRlLng7XG4gICAgICAgIHVpRGF0YS55ID0gbmV3U3RhdGUueTtcbiAgICAgICAgdWlEYXRhLmRlbHRhWCA9IG5ld1N0YXRlLnggLSB0aGlzLnN0YXRlLng7XG4gICAgICAgIHVpRGF0YS5kZWx0YVkgPSBuZXdTdGF0ZS55IC0gdGhpcy5zdGF0ZS55O1xuICAgICAgfVxuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uRHJhZyhlLCB1aURhdGEpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0b3BcIiwgKGUsIGNvcmVEYXRhKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSB0aGlzLnByb3BzLm9uU3RvcChlLCAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZURyYWdnYWJsZURhdGEpKHRoaXMsIGNvcmVEYXRhKSk7XG4gICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWdTdG9wOiAlaicsIGNvcmVEYXRhKTtcbiAgICAgIGNvbnN0IG5ld1N0YXRlIC8qOiBQYXJ0aWFsPERyYWdnYWJsZVN0YXRlPiovID0ge1xuICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIHNsYWNrWDogMCxcbiAgICAgICAgc2xhY2tZOiAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCBjb21wb25lbnQsIHRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb24gd2lsbCBiZSB0b1xuICAgICAgLy8gcmV2ZXJ0IGJhY2sgdG8gdGhlIG9sZCBwb3NpdGlvbi4gV2UgZXhwZWN0IGEgaGFuZGxlciBvbiBgb25EcmFnU3RvcGAsIGF0IHRoZSBsZWFzdC5cbiAgICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBCb29sZWFuKHRoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgaWYgKGNvbnRyb2xsZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gdGhpcy5wcm9wcy5wb3NpdGlvbjtcbiAgICAgICAgbmV3U3RhdGUueCA9IHg7XG4gICAgICAgIG5ld1N0YXRlLnkgPSB5O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBjdXJyZW50bHkgZHJhZ2dpbmcuXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAvLyBXaGV0aGVyIG9yIG5vdCB3ZSBoYXZlIGJlZW4gZHJhZ2dlZCBiZWZvcmUuXG4gICAgICBkcmFnZ2VkOiBmYWxzZSxcbiAgICAgIC8vIEN1cnJlbnQgdHJhbnNmb3JtIHggYW5kIHkuXG4gICAgICB4OiBwcm9wcy5wb3NpdGlvbiA/IHByb3BzLnBvc2l0aW9uLnggOiBwcm9wcy5kZWZhdWx0UG9zaXRpb24ueCxcbiAgICAgIHk6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueSA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi55LFxuICAgICAgcHJldlByb3BzUG9zaXRpb246IHtcbiAgICAgICAgLi4ucHJvcHMucG9zaXRpb25cbiAgICAgIH0sXG4gICAgICAvLyBVc2VkIGZvciBjb21wZW5zYXRpbmcgZm9yIG91dC1vZi1ib3VuZHMgZHJhZ3NcbiAgICAgIHNsYWNrWDogMCxcbiAgICAgIHNsYWNrWTogMCxcbiAgICAgIC8vIENhbiBvbmx5IGRldGVybWluZSBpZiBTVkcgYWZ0ZXIgbW91bnRpbmdcbiAgICAgIGlzRWxlbWVudFNWRzogZmFsc2VcbiAgICB9O1xuICAgIGlmIChwcm9wcy5wb3NpdGlvbiAmJiAhKHByb3BzLm9uRHJhZyB8fCBwcm9wcy5vblN0b3ApKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdBIGBwb3NpdGlvbmAgd2FzIGFwcGxpZWQgdG8gdGhpcyA8RHJhZ2dhYmxlPiwgd2l0aG91dCBkcmFnIGhhbmRsZXJzLiBUaGlzIHdpbGwgbWFrZSB0aGlzICcgKyAnY29tcG9uZW50IGVmZmVjdGl2ZWx5IHVuZHJhZ2dhYmxlLiBQbGVhc2UgYXR0YWNoIGBvbkRyYWdgIG9yIGBvblN0b3BgIGhhbmRsZXJzIHNvIHlvdSBjYW4gYWRqdXN0IHRoZSAnICsgJ2Bwb3NpdGlvbmAgb2YgdGhpcyBlbGVtZW50LicpO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVsZW1lbnQgcGFzc2VkIGlzIGFuIGluc3RhbmNlb2YgU1ZHRWxlbWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93LlNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuZmluZERPTU5vZGUoKSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNFbGVtZW50U1ZHOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkcmFnZ2luZzogZmFsc2VcbiAgICB9KTsgLy8gcHJldmVudHMgaW52YXJpYW50IGlmIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICB9XG5cbiAgLy8gUmVhY3QgU3RyaWN0IE1vZGUgY29tcGF0aWJpbGl0eTogaWYgYG5vZGVSZWZgIGlzIHBhc3NlZCwgd2Ugd2lsbCB1c2UgaXQgaW5zdGVhZCBvZiB0cnlpbmcgdG8gZmluZFxuICAvLyB0aGUgdW5kZXJseWluZyBET00gbm9kZSBvdXJzZWx2ZXMuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICBmaW5kRE9NTm9kZSgpIC8qOiA/SFRNTEVsZW1lbnQqL3tcbiAgICB2YXIgX3RoaXMkcHJvcHMkbm9kZVJlZiRjLCBfdGhpcyRwcm9wcztcbiAgICByZXR1cm4gKF90aGlzJHByb3BzJG5vZGVSZWYkYyA9IChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpID09PSBudWxsIHx8IF90aGlzJHByb3BzID09PSB2b2lkIDAgfHwgKF90aGlzJHByb3BzID0gX3RoaXMkcHJvcHMubm9kZVJlZikgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzLmN1cnJlbnQpICE9PSBudWxsICYmIF90aGlzJHByb3BzJG5vZGVSZWYkYyAhPT0gdm9pZCAwID8gX3RoaXMkcHJvcHMkbm9kZVJlZiRjIDogX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbiAgcmVuZGVyKCkgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgY29uc3Qge1xuICAgICAgYXhpcyxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVmYXVsdFBvc2l0aW9uLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZSxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZyxcbiAgICAgIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBwb3NpdGlvbk9mZnNldCxcbiAgICAgIHNjYWxlLFxuICAgICAgLi4uZHJhZ2dhYmxlQ29yZVByb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHN0eWxlID0ge307XG4gICAgbGV0IHN2Z1RyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGNvbnRyb2xsZWQsIHdlIGRvbid0IHdhbnQgdG8gbW92ZSBpdCAtIHVubGVzcyBpdCdzIGRyYWdnaW5nLlxuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBCb29sZWFuKHBvc2l0aW9uKTtcbiAgICBjb25zdCBkcmFnZ2FibGUgPSAhY29udHJvbGxlZCB8fCB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuICAgIGNvbnN0IHZhbGlkUG9zaXRpb24gPSBwb3NpdGlvbiB8fCBkZWZhdWx0UG9zaXRpb247XG4gICAgY29uc3QgdHJhbnNmb3JtT3B0cyA9IHtcbiAgICAgIC8vIFNldCBsZWZ0IGlmIGhvcml6b250YWwgZHJhZyBpcyBlbmFibGVkXG4gICAgICB4OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdYKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnggOiB2YWxpZFBvc2l0aW9uLngsXG4gICAgICAvLyBTZXQgdG9wIGlmIHZlcnRpY2FsIGRyYWcgaXMgZW5hYmxlZFxuICAgICAgeTogKDAsIF9wb3NpdGlvbkZucy5jYW5EcmFnWSkodGhpcykgJiYgZHJhZ2dhYmxlID8gdGhpcy5zdGF0ZS55IDogdmFsaWRQb3NpdGlvbi55XG4gICAgfTtcblxuICAgIC8vIElmIHRoaXMgZWxlbWVudCB3YXMgU1ZHLCB3ZSB1c2UgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZS5cbiAgICBpZiAodGhpcy5zdGF0ZS5pc0VsZW1lbnRTVkcpIHtcbiAgICAgIHN2Z1RyYW5zZm9ybSA9ICgwLCBfZG9tRm5zLmNyZWF0ZVNWR1RyYW5zZm9ybSkodHJhbnNmb3JtT3B0cywgcG9zaXRpb25PZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgYSBDU1MgdHJhbnNmb3JtIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kLiBUaGlzIGFsbG93cyB1cyB0byBtb3ZlIHRoZSBlbGVtZW50IGFyb3VuZFxuICAgICAgLy8gd2l0aG91dCB3b3JyeWluZyBhYm91dCB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZWxhdGl2ZWx5IG9yIGFic29sdXRlbHkgcG9zaXRpb25lZC5cbiAgICAgIC8vIElmIHRoZSBpdGVtIHlvdSBhcmUgZHJhZ2dpbmcgYWxyZWFkeSBoYXMgYSB0cmFuc2Zvcm0gc2V0LCB3cmFwIGl0IGluIGEgPHNwYW4+IHNvIDxEcmFnZ2FibGU+XG4gICAgICAvLyBoYXMgYSBjbGVhbiBzbGF0ZS5cbiAgICAgIHN0eWxlID0gKDAsIF9kb21GbnMuY3JlYXRlQ1NTVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gTWFyayB3aXRoIGNsYXNzIHdoaWxlIGRyYWdnaW5nXG4gICAgY29uc3QgY2xhc3NOYW1lID0gKDAsIF9jbHN4LmRlZmF1bHQpKGNoaWxkcmVuLnByb3BzLmNsYXNzTmFtZSB8fCAnJywgZGVmYXVsdENsYXNzTmFtZSwge1xuICAgICAgW2RlZmF1bHRDbGFzc05hbWVEcmFnZ2luZ106IHRoaXMuc3RhdGUuZHJhZ2dpbmcsXG4gICAgICBbZGVmYXVsdENsYXNzTmFtZURyYWdnZWRdOiB0aGlzLnN0YXRlLmRyYWdnZWRcbiAgICB9KTtcblxuICAgIC8vIFJldXNlIHRoZSBjaGlsZCBwcm92aWRlZFxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZmxleGlibGUgdG8gdXNlIHdoYXRldmVyIGVsZW1lbnQgaXMgd2FudGVkIChkaXYsIHVsLCBldGMpXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9EcmFnZ2FibGVDb3JlLmRlZmF1bHQsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVDb3JlUHJvcHMsIHtcbiAgICAgIG9uU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgb25TdG9wOiB0aGlzLm9uRHJhZ1N0b3BcbiAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi5jaGlsZHJlbi5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4uc3R5bGVcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IHN2Z1RyYW5zZm9ybVxuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkaXNwbGF5TmFtZVwiLCAnRHJhZ2dhYmxlJyk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8vIEFjY2VwdHMgYWxsIHByb3BzIDxEcmFnZ2FibGVDb3JlPiBhY2NlcHRzLlxuICAuLi5fRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LnByb3BUeXBlcyxcbiAgLyoqXG4gICAqIGBheGlzYCBkZXRlcm1pbmVzIHdoaWNoIGF4aXMgdGhlIGRyYWdnYWJsZSBjYW4gbW92ZS5cbiAgICpcbiAgICogIE5vdGUgdGhhdCBhbGwgY2FsbGJhY2tzIHdpbGwgc3RpbGwgcmV0dXJuIGRhdGEgYXMgbm9ybWFsLiBUaGlzIG9ubHlcbiAgICogIGNvbnRyb2xzIGZsdXNoaW5nIHRvIHRoZSBET00uXG4gICAqXG4gICAqICdib3RoJyBhbGxvd3MgbW92ZW1lbnQgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuICAgKiAneCcgbGltaXRzIG1vdmVtZW50IHRvIGhvcml6b250YWwgYXhpcy5cbiAgICogJ3knIGxpbWl0cyBtb3ZlbWVudCB0byB2ZXJ0aWNhbCBheGlzLlxuICAgKiAnbm9uZScgbGltaXRzIGFsbCBtb3ZlbWVudC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gJ2JvdGgnLlxuICAgKi9cbiAgYXhpczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mKFsnYm90aCcsICd4JywgJ3knLCAnbm9uZSddKSxcbiAgLyoqXG4gICAqIGBib3VuZHNgIGRldGVybWluZXMgdGhlIHJhbmdlIG9mIG1vdmVtZW50IGF2YWlsYWJsZSB0byB0aGUgZWxlbWVudC5cbiAgICogQXZhaWxhYmxlIHZhbHVlcyBhcmU6XG4gICAqXG4gICAqICdwYXJlbnQnIHJlc3RyaWN0cyBtb3ZlbWVudCB3aXRoaW4gdGhlIERyYWdnYWJsZSdzIHBhcmVudCBub2RlLlxuICAgKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgYWxsIG9mIHdoaWNoIGFyZSBvcHRpb25hbDpcbiAgICpcbiAgICoge2xlZnQ6IExFRlRfQk9VTkQsIHJpZ2h0OiBSSUdIVF9CT1VORCwgYm90dG9tOiBCT1RUT01fQk9VTkQsIHRvcDogVE9QX0JPVU5EfVxuICAgKlxuICAgKiBBbGwgdmFsdWVzIGFyZSBpbiBweC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICA8RHJhZ2dhYmxlIGJvdW5kcz17e3JpZ2h0OiAzMDAsIGJvdHRvbTogMzAwfX0+XG4gICAqICAgICAgICAgICAgICA8ZGl2PkNvbnRlbnQ8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBib3VuZHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgbGVmdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICByaWdodDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgYm90dG9tOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoW2ZhbHNlXSldKSxcbiAgZGVmYXVsdENsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLyoqXG4gICAqIGBkZWZhdWx0UG9zaXRpb25gIHNwZWNpZmllcyB0aGUgeCBhbmQgeSB0aGF0IHRoZSBkcmFnZ2VkIGl0ZW0gc2hvdWxkIHN0YXJ0IGF0XG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIGRlZmF1bHRQb3NpdGlvbj17e3g6IDI1LCB5OiAyNX19PlxuICAgKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pkkgc3RhcnQgd2l0aCB0cmFuc2Zvcm1YOiAyNXB4IGFuZCB0cmFuc2Zvcm1ZOiAyNXB4OzwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICAgICAgKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGRlZmF1bHRQb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG4gIHBvc2l0aW9uT2Zmc2V0OiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKSxcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLCBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nXSlcbiAgfSksXG4gIC8qKlxuICAgKiBgcG9zaXRpb25gLCBpZiBwcmVzZW50LCBkZWZpbmVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIGhvdyBmb3JtIGVsZW1lbnRzIGluIFJlYWN0IHdvcmsgLSBpZiBubyBgcG9zaXRpb25gIGlzIHN1cHBsaWVkLCB0aGUgY29tcG9uZW50XG4gICAqICBpcyB1bmNvbnRyb2xsZWQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYGpzeFxuICAgKiAgICAgIGxldCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgKiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICogICAgICAgICAgICAgICAgICA8RHJhZ2dhYmxlIHBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgcG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICAvKipcbiAgICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgY2hpbGQsIG5vdCBoZXJlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBfc2hpbXMuZG9udFNldE1lLFxuICBzdHlsZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgdHJhbnNmb3JtOiBfc2hpbXMuZG9udFNldE1lXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgLi4uX0RyYWdnYWJsZUNvcmUuZGVmYXVsdC5kZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyxcbiAgYm91bmRzOiBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogJ3JlYWN0LWRyYWdnYWJsZScsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2luZzogJ3JlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZycsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnZWQnLFxuICBkZWZhdWx0UG9zaXRpb246IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSxcbiAgc2NhbGU6IDFcbn0pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfRHJhZ2dhYmxlQ29yZSIsImRlZmF1bHQiLCJSZWFjdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwicmVxdWlyZSIsIl9wcm9wVHlwZXMiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX3JlYWN0RG9tIiwiX2Nsc3giLCJfZG9tRm5zIiwiX3Bvc2l0aW9uRm5zIiwiX3NoaW1zIiwiX2xvZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiYXBwbHkiLCJfZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiRHJhZ2dhYmxlIiwiQ29tcG9uZW50IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiX3JlZiIsIl9yZWYyIiwicG9zaXRpb24iLCJwcmV2UHJvcHNQb3NpdGlvbiIsIngiLCJ5IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImUiLCJjb3JlRGF0YSIsInNob3VsZFN0YXJ0Iiwib25TdGFydCIsImNyZWF0ZURyYWdnYWJsZURhdGEiLCJzZXRTdGF0ZSIsImRyYWdnaW5nIiwiZHJhZ2dlZCIsInN0YXRlIiwidWlEYXRhIiwibmV3U3RhdGUiLCJzbGFja1giLCJzbGFja1kiLCJib3VuZHMiLCJuZXdTdGF0ZVgiLCJuZXdTdGF0ZVkiLCJnZXRCb3VuZFBvc2l0aW9uIiwiZGVsdGFYIiwiZGVsdGFZIiwic2hvdWxkVXBkYXRlIiwib25EcmFnIiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJjb250cm9sbGVkIiwiQm9vbGVhbiIsImRlZmF1bHRQb3NpdGlvbiIsImlzRWxlbWVudFNWRyIsImNvbnNvbGUiLCJ3YXJuIiwiY29tcG9uZW50RGlkTW91bnQiLCJ3aW5kb3ciLCJTVkdFbGVtZW50IiwiZmluZERPTU5vZGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJHByb3BzJG5vZGVSZWYkYyIsIl90aGlzJHByb3BzIiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJheGlzIiwiY2hpbGRyZW4iLCJkZWZhdWx0Q2xhc3NOYW1lIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nIiwiZGVmYXVsdENsYXNzTmFtZURyYWdnZWQiLCJwb3NpdGlvbk9mZnNldCIsInNjYWxlIiwiZHJhZ2dhYmxlQ29yZVByb3BzIiwic3R5bGUiLCJzdmdUcmFuc2Zvcm0iLCJkcmFnZ2FibGUiLCJ2YWxpZFBvc2l0aW9uIiwidHJhbnNmb3JtT3B0cyIsImNhbkRyYWdYIiwiY2FuRHJhZ1kiLCJjcmVhdGVTVkdUcmFuc2Zvcm0iLCJjcmVhdGVDU1NUcmFuc2Zvcm0iLCJjbGFzc05hbWUiLCJjcmVhdGVFbGVtZW50Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdG9wIiwiY2xvbmVFbGVtZW50IiwiQ2hpbGRyZW4iLCJvbmx5IiwidHJhbnNmb3JtIiwicHJvcFR5cGVzIiwib25lT2YiLCJvbmVPZlR5cGUiLCJzaGFwZSIsImxlZnQiLCJudW1iZXIiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsInN0cmluZyIsImRvbnRTZXRNZSIsImRlZmF1bHRQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/Draggable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.0.5-canary.58_@babel+core@7.9.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/.pnpm/next@14.0.5-canary.58_@babel+core@7.9.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.\nconst eventsFor = {\n    touch: {\n        start: \"touchstart\",\n        move: \"touchmove\",\n        stop: \"touchend\"\n    },\n    mouse: {\n        start: \"mousedown\",\n        move: \"mousemove\",\n        stop: \"mouseup\"\n    }\n};\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/ /*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/ //\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"dragging\", false);\n        // Used while dragging to determine deltas.\n        _defineProperty(this, \"lastX\", NaN);\n        _defineProperty(this, \"lastY\", NaN);\n        _defineProperty(this, \"touchIdentifier\", null);\n        _defineProperty(this, \"mounted\", false);\n        _defineProperty(this, \"handleDragStart\", (e)=>{\n            // Make it possible to attach event handlers on top of this one.\n            this.props.onMouseDown(e);\n            // Only accept left-clicks.\n            if (!this.props.allowAnyClick && typeof e.button === \"number\" && e.button !== 0) return false;\n            // Get nodes. Be sure to grab relative document (could be iframed)\n            const thisNode = this.findDOMNode();\n            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n                throw new Error(\"<DraggableCore> not mounted on DragStart!\");\n            }\n            const { ownerDocument } = thisNode;\n            // Short circuit if handle or cancel prop was provided and selector doesn't match.\n            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n                return;\n            }\n            // Prevent scrolling on mobile devices, like ipad/iphone.\n            // Important that this is after handle/cancel.\n            if (e.type === \"touchstart\") e.preventDefault();\n            // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n            this.touchIdentifier = touchIdentifier;\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n            if (position == null) return; // not possible but satisfies flow\n            const { x, y } = position;\n            // Create an event object with all the data parents need to make a decision here.\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDragStart: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, cancel.\n            (0, _log.default)(\"calling\", this.props.onStart);\n            const shouldUpdate = this.props.onStart(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) return;\n            // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n            // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n            this.dragging = true;\n            this.lastX = x;\n            this.lastY = y;\n            // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n        });\n        _defineProperty(this, \"handleDrag\", (e)=>{\n            // Get the current drag point from the event. This is used as the offset.\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX, deltaY = y - this.lastY;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                if (!deltaX && !deltaY) return; // skip useless drag\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            (0, _log.default)(\"DraggableCore: handleDrag: %j\", coreEvent);\n            // Call event handler. If it returns explicit false, trigger end.\n            const shouldUpdate = this.props.onDrag(e, coreEvent);\n            if (shouldUpdate === false || this.mounted === false) {\n                try {\n                    // $FlowIgnore\n                    this.handleDragStop(new MouseEvent(\"mouseup\"));\n                } catch (err) {\n                    // Old browsers\n                    const event = document.createEvent(\"MouseEvents\");\n                    // I see why this insanity was deprecated\n                    // $FlowIgnore\n                    event.initMouseEvent(\"mouseup\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n                    this.handleDragStop(event);\n                }\n                return;\n            }\n            this.lastX = x;\n            this.lastY = y;\n        });\n        _defineProperty(this, \"handleDragStop\", (e)=>{\n            if (!this.dragging) return;\n            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n            if (position == null) return;\n            let { x, y } = position;\n            // Snap to grid if prop has been provided\n            if (Array.isArray(this.props.grid)) {\n                let deltaX = x - this.lastX || 0;\n                let deltaY = y - this.lastY || 0;\n                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n                x = this.lastX + deltaX, y = this.lastY + deltaY;\n            }\n            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n            // Call event handler\n            const shouldContinue = this.props.onStop(e, coreEvent);\n            if (shouldContinue === false || this.mounted === false) return false;\n            const thisNode = this.findDOMNode();\n            if (thisNode) {\n                // Remove user-select hack\n                if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n            }\n            (0, _log.default)(\"DraggableCore: handleDragStop: %j\", coreEvent);\n            // Reset the el.\n            this.dragging = false;\n            this.lastX = NaN;\n            this.lastY = NaN;\n            if (thisNode) {\n                // Remove event handlers\n                (0, _log.default)(\"DraggableCore: Removing handlers\");\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n            }\n        });\n        _defineProperty(this, \"onMouseDown\", (e)=>{\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onMouseUp\", (e)=>{\n            dragEventFor = eventsFor.mouse;\n            return this.handleDragStop(e);\n        });\n        // Same as onMouseDown (start drag), but now consider this a touch device.\n        _defineProperty(this, \"onTouchStart\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStart(e);\n        });\n        _defineProperty(this, \"onTouchEnd\", (e)=>{\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return this.handleDragStop(e);\n        });\n    }\n    componentDidMount() {\n        this.mounted = true;\n        // Touch handlers must be added with {passive: false} to be cancelable.\n        // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n        }\n    }\n    componentWillUnmount() {\n        this.mounted = false;\n        // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n        const thisNode = this.findDOMNode();\n        if (thisNode) {\n            const { ownerDocument } = thisNode;\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n                passive: false\n            });\n            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n        }\n    }\n    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n    // the underlying DOM node ourselves. See the README for more information.\n    findDOMNode() /*: ?HTMLElement*/ {\n        var _this$props, _this$props2;\n        return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n    }\n    render() /*: React.Element<any>*/ {\n        // Reuse the child provided\n        // This makes it flexible to use whatever element is wanted (div, ul, etc)\n        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {\n            // Note: mouseMove handler is attached to document so it will still function\n            // when the user drags quickly and leaves the bounds of the element.\n            onMouseDown: this.onMouseDown,\n            onMouseUp: this.onMouseUp,\n            // onTouchStart is added on `componentDidMount` so they can be added with\n            // {passive: false}, which allows it to cancel. See\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            onTouchEnd: this.onTouchEnd\n        });\n    }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", \"DraggableCore\");\n_defineProperty(DraggableCore, \"propTypes\", {\n    /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */ allowAnyClick: _propTypes.default.bool,\n    children: _propTypes.default.node.isRequired,\n    /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */ disabled: _propTypes.default.bool,\n    /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */ enableUserSelectHack: _propTypes.default.bool,\n    /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {\n        if (props[propName] && props[propName].nodeType !== 1) {\n            throw new Error(\"Draggable's offsetParent must be a DOM Node.\");\n        }\n    },\n    /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */ handle: _propTypes.default.string,\n    /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */ cancel: _propTypes.default.string,\n    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */ nodeRef: _propTypes.default.object,\n    /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onStart: _propTypes.default.func,\n    /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */ onDrag: _propTypes.default.func,\n    /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */ onStop: _propTypes.default.func,\n    /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */ onMouseDown: _propTypes.default.func,\n    /**\n   * `scale`, if set, applies scaling while dragging an element\n   */ scale: _propTypes.default.number,\n    /**\n   * These properties should be defined on the child, not here.\n   */ className: _shims.dontSetMe,\n    style: _shims.dontSetMe,\n    transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n    allowAnyClick: false,\n    // by default only accept left click\n    disabled: false,\n    enableUserSelectHack: true,\n    onStart: function() {},\n    onDrag: function() {},\n    onStop: function() {},\n    onMouseDown: function() {},\n    scale: 1\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZUNvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYkEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxRQUFRQyx3QkFBd0JDLG1CQUFPQSxDQUFDLGlNQUFPO0FBQ25ELElBQUlDLGFBQWFDLHVCQUF1QkYsbUJBQU9BLENBQUMsaUdBQVk7QUFDNUQsSUFBSUcsWUFBWUQsdUJBQXVCRixtQkFBT0EsQ0FBQyx5TUFBVztBQUMxRCxJQUFJSSxVQUFVSixtQkFBT0EsQ0FBQyw2SkFBZ0I7QUFDdEMsSUFBSUssZUFBZUwsbUJBQU9BLENBQUMsdUtBQXFCO0FBQ2hELElBQUlNLFNBQVNOLG1CQUFPQSxDQUFDLDJKQUFlO0FBQ3BDLElBQUlPLE9BQU9MLHVCQUF1QkYsbUJBQU9BLENBQUMsdUpBQWE7QUFDdkQsU0FBU0UsdUJBQXVCTSxHQUFHO0lBQUksT0FBT0EsT0FBT0EsSUFBSUMsVUFBVSxHQUFHRCxNQUFNO1FBQUVYLFNBQVNXO0lBQUk7QUFBRztBQUM5RixTQUFTRSx5QkFBeUJDLFdBQVc7SUFBSSxJQUFJLE9BQU9DLFlBQVksWUFBWSxPQUFPO0lBQU0sSUFBSUMsb0JBQW9CLElBQUlEO0lBQVcsSUFBSUUsbUJBQW1CLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBVUMsV0FBVztRQUFJLE9BQU9BLGNBQWNHLG1CQUFtQkQ7SUFBbUIsR0FBR0Y7QUFBYztBQUN0VCxTQUFTWix3QkFBd0JTLEdBQUcsRUFBRUcsV0FBVztJQUFJLElBQUksQ0FBQ0EsZUFBZUgsT0FBT0EsSUFBSUMsVUFBVSxFQUFFO1FBQUUsT0FBT0Q7SUFBSztJQUFFLElBQUlBLFFBQVEs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QUFJO0lBQy9COzs7R0FHQyxHQUNEN0IsUUFBUTVHLFdBQVdKLE9BQU8sQ0FBQzZJLElBQUk7SUFDL0I7OztHQUdDLEdBQ0RoRixhQUFhekQsV0FBV0osT0FBTyxDQUFDNkksSUFBSTtJQUNwQzs7R0FFQyxHQUNEQyxPQUFPMUksV0FBV0osT0FBTyxDQUFDMEksTUFBTTtJQUNoQzs7R0FFQyxHQUNESyxXQUFXdEksT0FBT3VJLFNBQVM7SUFDM0JDLE9BQU94SSxPQUFPdUksU0FBUztJQUN2QkUsV0FBV3pJLE9BQU91SSxTQUFTO0FBQzdCO0FBQ0FsSCxnQkFBZ0J3QixlQUFlLGdCQUFnQjtJQUM3Q1EsZUFBZTtJQUNmLG9DQUFvQztJQUNwQ08sVUFBVTtJQUNWb0Isc0JBQXNCO0lBQ3RCSCxTQUFTLFlBQWE7SUFDdEJpQixRQUFRLFlBQWE7SUFDckJTLFFBQVEsWUFBYTtJQUNyQm5ELGFBQWEsWUFBYTtJQUMxQmlGLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjQuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzPzdjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0V2ZW50SGFuZGxlciwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLy8gU2ltcGxlIGFic3RyYWN0aW9uIGZvciBkcmFnZ2luZyBldmVudHMgbmFtZXMuXG5jb25zdCBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cbmxldCBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG4vKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyfHN0cmluZywgeTogbnVtYmVyfHN0cmluZ307Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBib29sZWFuLFxuICBvblN0YXJ0OiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uRHJhZzogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVDb3JlUHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIG9mZnNldFBhcmVudDogSFRNTEVsZW1lbnQsXG4gIGdyaWQ6IFtudW1iZXIsIG51bWJlcl0sXG4gIGhhbmRsZTogc3RyaW5nLFxuICBub2RlUmVmPzogP1JlYWN0LkVsZW1lbnRSZWY8YW55Pixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZUNvcmU+LlxuLy9cbi8vIDxEcmFnZ2FibGVDb3JlPiBpcyBmb3IgYWR2YW5jZWQgdXNhZ2Ugb2YgPERyYWdnYWJsZT4uIEl0IG1haW50YWlucyBtaW5pbWFsIGludGVybmFsIHN0YXRlIHNvIGl0IGNhblxuLy8gd29yayB3ZWxsIHdpdGggbGlicmFyaWVzIHRoYXQgcmVxdWlyZSBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZWxlbWVudC5cbi8vXG5cbmNsYXNzIERyYWdnYWJsZUNvcmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlQ29yZVByb3BzPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAvLyBVc2VkIHdoaWxlIGRyYWdnaW5nIHRvIGRldGVybWluZSBkZWx0YXMuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFhcIiwgTmFOKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0WVwiLCBOYU4pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoSWRlbnRpZmllclwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb3VudGVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXG4gICAgICAvLyBPbmx5IGFjY2VwdCBsZWZ0LWNsaWNrcy5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gR2V0IG5vZGVzLiBCZSBzdXJlIHRvIGdyYWIgcmVsYXRpdmUgZG9jdW1lbnQgKGNvdWxkIGJlIGlmcmFtZWQpXG4gICAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPiBub3QgbW91bnRlZCBvbiBEcmFnU3RhcnQhJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzTm9kZTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIShlLnRhcmdldCBpbnN0YW5jZW9mIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkgfHwgdGhpcy5wcm9wcy5oYW5kbGUgJiYgISgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIHRoaXMucHJvcHMuaGFuZGxlLCB0aGlzTm9kZSkgfHwgdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgdGhpcy5wcm9wcy5jYW5jZWwsIHRoaXNOb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXZpY2VzLCBsaWtlIGlwYWQvaXBob25lLlxuICAgICAgLy8gSW1wb3J0YW50IHRoYXQgdGhpcyBpcyBhZnRlciBoYW5kbGUvY2FuY2VsLlxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFNldCB0b3VjaCBpZGVudGlmaWVyIGluIGNvbXBvbmVudCBzdGF0ZSBpZiB0aGlzIGlzIGEgdG91Y2ggZXZlbnQuIFRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGluZGl2aWR1YWwgdG91Y2hlcyBvbiBtdWx0aXRvdWNoIHNjcmVlbnMgYnkgaWRlbnRpZnlpbmcgd2hpY2hcbiAgICAgIC8vIHRvdWNocG9pbnQgd2FzIHNldCB0byB0aGlzIGVsZW1lbnQuXG4gICAgICBjb25zdCB0b3VjaElkZW50aWZpZXIgPSAoMCwgX2RvbUZucy5nZXRUb3VjaElkZW50aWZpZXIpKGUpO1xuICAgICAgdGhpcy50b3VjaElkZW50aWZpZXIgPSB0b3VjaElkZW50aWZpZXI7XG5cbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuOyAvLyBub3QgcG9zc2libGUgYnV0IHNhdGlzZmllcyBmbG93XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSBwYXJlbnRzIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhlcmUuXG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RhcnQ6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCBjYW5jZWwuXG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnY2FsbGluZycsIHRoaXMucHJvcHMub25TdGFydCk7XG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cbiAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuICAgICAgLy8gc28gd2Uga25vdyBob3cgbXVjaCB3ZSd2ZSBtb3ZlZCBkdXJpbmcgdGhlIGRyYWcuIFRoaXMgYWxsb3dzIHVzXG4gICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RYID0geDtcbiAgICAgIHRoaXMubGFzdFkgPSB5O1xuXG4gICAgICAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcbiAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdcIiwgZSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0aGlzLnRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgcHJvcCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5ncmlkKSkge1xuICAgICAgICBsZXQgZGVsdGFYID0geCAtIHRoaXMubGFzdFgsXG4gICAgICAgICAgZGVsdGFZID0geSAtIHRoaXMubGFzdFk7XG4gICAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKHRoaXMucHJvcHMuZ3JpZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSByZXR1cm47IC8vIHNraXAgdXNlbGVzcyBkcmFnXG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWc6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdG9wKG5ldyBNb3VzZUV2ZW50KCdtb3VzZXVwJykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBPbGQgYnJvd3NlcnNcbiAgICAgICAgICBjb25zdCBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJykgLyo6IGFueSovKSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pO1xuICAgICAgICAgIC8vIEkgc2VlIHdoeSB0aGlzIGluc2FuaXR5IHdhcyBkZXByZWNhdGVkXG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2V1cCcsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0b3AoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFggPSB4O1xuICAgICAgdGhpcy5sYXN0WSA9IHk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1N0b3BcIiwgZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRoaXMudG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBsZXQge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIGxldCBkZWx0YVggPSB4IC0gdGhpcy5sYXN0WCB8fCAwO1xuICAgICAgICBsZXQgZGVsdGFZID0geSAtIHRoaXMubGFzdFkgfHwgMDtcbiAgICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9ICgwLCBfcG9zaXRpb25GbnMuc25hcFRvR3JpZCkodGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBlbC5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFggPSBOYU47XG4gICAgICB0aGlzLmxhc3RZID0gTmFOO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTW91c2VEb3duXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlOyAvLyBvbiB0b3VjaHNjcmVlbiBsYXB0b3BzIHdlIGNvdWxkIHN3aXRjaCBiYWNrIHRvIG1vdXNlXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlVXBcIiwgZSA9PiB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgICAvLyBTYW1lIGFzIG9uTW91c2VEb3duIChzdGFydCBkcmFnKSwgYnV0IG5vdyBjb25zaWRlciB0aGlzIGEgdG91Y2ggZGV2aWNlLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hFbmRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgLy8gVG91Y2ggaGFuZGxlcnMgbXVzdCBiZSBhZGRlZCB3aXRoIHtwYXNzaXZlOiBmYWxzZX0gdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KSh0aGlzTm9kZSwgZXZlbnRzRm9yLnRvdWNoLnN0YXJ0LCB0aGlzLm9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgdmFyIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wczI7XG4gICAgcmV0dXJuIChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpICE9PSBudWxsICYmIF90aGlzJHByb3BzICE9PSB2b2lkIDAgJiYgX3RoaXMkcHJvcHMubm9kZVJlZiA/IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczIgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMyID0gX3RoaXMkcHJvcHMyLm5vZGVSZWYpID09PSBudWxsIHx8IF90aGlzJHByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMyLmN1cnJlbnQgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki97XG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgLy8gb25Ub3VjaFN0YXJ0IGlzIGFkZGVkIG9uIGBjb21wb25lbnREaWRNb3VudGAgc28gdGhleSBjYW4gYmUgYWRkZWQgd2l0aFxuICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZUNvcmUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8qKlxuICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG4gICAqIEJ5IGRlZmF1bHQsIHdlIG9ubHkgYWNjZXB0IHRoZSBsZWZ0IGJ1dHRvbi5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93QW55Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGBkaXNhYmxlZGAsIGlmIHRydWUsIHN0b3BzIHRoZSA8RHJhZ2dhYmxlPiBmcm9tIGRyYWdnaW5nLiBBbGwgaGFuZGxlcnMsXG4gICAqIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgb25Nb3VzZURvd25gLCB3aWxsIG5vdCBmaXJlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgd2UgYWRkICd1c2VyLXNlbGVjdDpub25lJyBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBib2R5XG4gICAqIHRvIHByZXZlbnQgdWdseSB0ZXh0IHNlbGVjdGlvbiBkdXJpbmcgZHJhZy4gSWYgdGhpcyBpcyBjYXVzaW5nIHByb2JsZW1zXG4gICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIGBvZmZzZXRQYXJlbnRgLCBpZiBzZXQsIHVzZXMgdGhlIHBhc3NlZCBET00gbm9kZSB0byBjb21wdXRlIGRyYWcgb2Zmc2V0c1xuICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cbiAgICovXG4gIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKHByb3BzIC8qOiBEcmFnZ2FibGVDb3JlUHJvcHMqLywgcHJvcE5hbWUgLyo6ICRLZXlzPERyYWdnYWJsZUNvcmVQcm9wcz4qLykge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgcHJvcHNbcHJvcE5hbWVdLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZVxcJ3Mgb2Zmc2V0UGFyZW50IG11c3QgYmUgYSBET00gTm9kZS4nKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG4gICAqL1xuICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLyoqXG4gICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuICAgKiAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhhbmRsZVwiPkNsaWNrIG1lIHRvIGRyYWc8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qKlxuICAgKiBgY2FuY2VsYCBzcGVjaWZpZXMgYSBzZWxlY3RvciB0byBiZSB1c2VkIHRvIHByZXZlbnQgZHJhZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICByZXR1cm4oXG4gICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG4gICAqICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW5jZWxcIj5Zb3UgY2FuJ3QgZHJhZyBmcm9tIGhlcmU8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qIElmIHJ1bm5pbmcgaW4gUmVhY3QgU3RyaWN0IG1vZGUsIFJlYWN0RE9NLmZpbmRET01Ob2RlKCkgaXMgZGVwcmVjYXRlZC5cbiAgICogVW5mb3J0dW5hdGVseSwgaW4gb3JkZXIgZm9yIDxEcmFnZ2FibGU+IHRvIHdvcmsgcHJvcGVybHksIHdlIG5lZWQgcmF3IGFjY2Vzc1xuICAgKiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gSWYgeW91IHdhbnQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHBhc3MgYSBgbm9kZVJlZmBcbiAgICogYXMgaW4gdGhpcyBleGFtcGxlOlxuICAgKlxuICAgKiBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHtcbiAgICogICBjb25zdCBub2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8RHJhZ2dhYmxlIG5vZGVSZWY9e25vZGVSZWZ9PlxuICAgKiAgICAgICA8ZGl2IHJlZj17bm9kZVJlZn0+RXhhbXBsZSBUYXJnZXQ8L2Rpdj5cbiAgICogICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICk7XG4gICAqIH1cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgYXJiaXRyYXJpbHkgbmVzdGVkIGNvbXBvbmVudHMsIHNvIGxvbmcgYXMgdGhlIHJlZiBlbmRzIHVwXG4gICAqIHBvaW50aW5nIHRvIHRoZSBhY3R1YWwgY2hpbGQgRE9NIG5vZGUgYW5kIG5vdCBhIGN1c3RvbSBjb21wb25lbnQuXG4gICAqL1xuICBub2RlUmVmOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuICAgKi9cbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIHRoZSBkcmFnIHdpbGwgcmVtYWluIGFjdGl2ZS5cbiAgICovXG4gIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG4gICAqIHNpbmNlIGl0J2xsIGFsd2F5cyBiZSBibG9ja2VkIChhcyB0aGVyZSBpcyBpbnRlcm5hbCB1c2Ugb2Ygb25Nb3VzZURvd24pXG4gICAqL1xuICBvbk1vdXNlRG93bjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBgc2NhbGVgLCBpZiBzZXQsIGFwcGxpZXMgc2NhbGluZyB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50XG4gICAqL1xuICBzY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cbiAgICovXG4gIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG4gIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxufSk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd0FueUNsaWNrOiBmYWxzZSxcbiAgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBvbkRyYWc6IGZ1bmN0aW9uICgpIHt9LFxuICBvblN0b3A6IGZ1bmN0aW9uICgpIHt9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge30sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfcHJvcFR5cGVzIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9yZWFjdERvbSIsIl9kb21GbnMiLCJfcG9zaXRpb25GbnMiLCJfc2hpbXMiLCJfbG9nIiwib2JqIiwiX19lc01vZHVsZSIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5vZGVJbnRlcm9wIiwiV2Vha01hcCIsImNhY2hlQmFiZWxJbnRlcm9wIiwiY2FjaGVOb2RlSW50ZXJvcCIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsIl9kZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiYXJnIiwiX3RvUHJpbWl0aXZlIiwiU3RyaW5nIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiZXZlbnRzRm9yIiwidG91Y2giLCJzdGFydCIsIm1vdmUiLCJzdG9wIiwibW91c2UiLCJkcmFnRXZlbnRGb3IiLCJEcmFnZ2FibGVDb3JlIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJOYU4iLCJlIiwicHJvcHMiLCJvbk1vdXNlRG93biIsImFsbG93QW55Q2xpY2siLCJidXR0b24iLCJ0aGlzTm9kZSIsImZpbmRET01Ob2RlIiwib3duZXJEb2N1bWVudCIsImJvZHkiLCJFcnJvciIsImRpc2FibGVkIiwidGFyZ2V0IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwiaGFuZGxlIiwibWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvIiwiY2FuY2VsIiwidHlwZSIsInByZXZlbnREZWZhdWx0IiwidG91Y2hJZGVudGlmaWVyIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwicG9zaXRpb24iLCJnZXRDb250cm9sUG9zaXRpb24iLCJ4IiwieSIsImNvcmVFdmVudCIsImNyZWF0ZUNvcmVEYXRhIiwib25TdGFydCIsInNob3VsZFVwZGF0ZSIsIm1vdW50ZWQiLCJlbmFibGVVc2VyU2VsZWN0SGFjayIsImFkZFVzZXJTZWxlY3RTdHlsZXMiLCJkcmFnZ2luZyIsImxhc3RYIiwibGFzdFkiLCJhZGRFdmVudCIsImhhbmRsZURyYWciLCJoYW5kbGVEcmFnU3RvcCIsIkFycmF5IiwiaXNBcnJheSIsImdyaWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJzbmFwVG9HcmlkIiwib25EcmFnIiwiTW91c2VFdmVudCIsImVyciIsImV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRNb3VzZUV2ZW50Iiwid2luZG93Iiwic2hvdWxkQ29udGludWUiLCJvblN0b3AiLCJyZW1vdmVVc2VyU2VsZWN0U3R5bGVzIiwicmVtb3ZlRXZlbnQiLCJoYW5kbGVEcmFnU3RhcnQiLCJjb21wb25lbnREaWRNb3VudCIsIm9uVG91Y2hTdGFydCIsInBhc3NpdmUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl90aGlzJHByb3BzIiwiX3RoaXMkcHJvcHMyIiwibm9kZVJlZiIsImN1cnJlbnQiLCJyZW5kZXIiLCJjbG9uZUVsZW1lbnQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZHJlbiIsIm9uTW91c2VVcCIsIm9uVG91Y2hFbmQiLCJib29sIiwibm9kZSIsImlzUmVxdWlyZWQiLCJvZmZzZXRQYXJlbnQiLCJwcm9wTmFtZSIsIm5vZGVUeXBlIiwiYXJyYXlPZiIsIm51bWJlciIsInN0cmluZyIsIm9iamVjdCIsImZ1bmMiLCJzY2FsZSIsImNsYXNzTmFtZSIsImRvbnRTZXRNZSIsInN0eWxlIiwidHJhbnNmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/DraggableCore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/cjs.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/cjs.js ***!
  \******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { default: Draggable, DraggableCore } = __webpack_require__(/*! ./Draggable */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/Draggable.js\");\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLE1BQU0sRUFDSkEsU0FBU0MsU0FBUyxFQUNsQkMsYUFBYSxFQUNkLEdBQUdDLG1CQUFPQSxDQUFDO0FBRVoseUpBQXlKO0FBQ3pKLDZEQUE2RDtBQUM3RCwrREFBK0Q7QUFDL0RDLE9BQU9DLE9BQU8sR0FBR0o7QUFDakJHLHlCQUFzQixHQUFHSDtBQUN6QkcsNEJBQTRCLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2kvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL2Nqcy5qcz8xMDE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7XG4gIGRlZmF1bHQ6IERyYWdnYWJsZSxcbiAgRHJhZ2dhYmxlQ29yZVxufSA9IHJlcXVpcmUoJy4vRHJhZ2dhYmxlJyk7XG5cbi8vIFByZXZpb3VzIHZlcnNpb25zIG9mIHRoaXMgbGliIGV4cG9ydGVkIDxEcmFnZ2FibGU+IGFzIHRoZSByb290IGV4cG9ydC4gQXMgdG8gbm8tLy8gdGhlbSwgb3IgVHlwZVNjcmlwdCwgd2UgZXhwb3J0ICpib3RoKiBhcyB0aGUgcm9vdCBhbmQgYXMgJ2RlZmF1bHQnLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9wdWxsLzI1NFxuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL3JlYWN0LWRyYWdnYWJsZS9pc3N1ZXMvMjY2XG5tb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5EcmFnZ2FibGVDb3JlID0gRHJhZ2dhYmxlQ29yZTsiXSwibmFtZXMiOlsiZGVmYXVsdCIsIkRyYWdnYWJsZSIsIkRyYWdnYWJsZUNvcmUiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.removeUserSelectStyles = removeUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = \"\";\nfunction matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {\n    if (!matchesSelectorFunc) {\n        matchesSelectorFunc = (0, _shims.findInArray)([\n            \"matches\",\n            \"webkitMatchesSelector\",\n            \"mozMatchesSelector\",\n            \"msMatchesSelector\",\n            \"oMatchesSelector\"\n        ], function(method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return (0, _shims.isFunction)(el[method]);\n        });\n    }\n    // Might not be found entirely (not an Element?) - in that case, bail\n    // $FlowIgnore: Doesn't think elements are indexable\n    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n    // $FlowIgnore: Doesn't think elements are indexable\n    return el[matchesSelectorFunc](selector);\n}\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {\n    let node = el;\n    do {\n        if (matchesSelector(node, selector)) return true;\n        if (node === baseNode) return false;\n        // $FlowIgnore[incompatible-type]\n        node = node.parentNode;\n    }while (node);\n    return false;\n}\nfunction addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.addEventListener) {\n        el.addEventListener(event, handler, options);\n    } else if (el.attachEvent) {\n        el.attachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = handler;\n    }\n}\nfunction removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {\n    if (!el) return;\n    const options = {\n        capture: true,\n        ...inputOptions\n    };\n    // $FlowIgnore[method-unbinding]\n    if (el.removeEventListener) {\n        el.removeEventListener(event, handler, options);\n    } else if (el.detachEvent) {\n        el.detachEvent(\"on\" + event, handler);\n    } else {\n        // $FlowIgnore: Doesn't think elements are indexable\n        el[\"on\" + event] = null;\n    }\n}\nfunction outerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetTop which is including margin. See getBoundPosition\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height += (0, _shims.int)(computedStyle.borderTopWidth);\n    height += (0, _shims.int)(computedStyle.borderBottomWidth);\n    return height;\n}\nfunction outerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    // This is deliberately excluding margin for our calculations, since we are using\n    // offsetLeft which is including margin. See getBoundPosition\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width += (0, _shims.int)(computedStyle.borderLeftWidth);\n    width += (0, _shims.int)(computedStyle.borderRightWidth);\n    return width;\n}\nfunction innerHeight(node /*: HTMLElement*/ ) /*: number*/ {\n    let height = node.clientHeight;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    height -= (0, _shims.int)(computedStyle.paddingTop);\n    height -= (0, _shims.int)(computedStyle.paddingBottom);\n    return height;\n}\nfunction innerWidth(node /*: HTMLElement*/ ) /*: number*/ {\n    let width = node.clientWidth;\n    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n    width -= (0, _shims.int)(computedStyle.paddingLeft);\n    width -= (0, _shims.int)(computedStyle.paddingRight);\n    return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/ // Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {\n    const isBody = offsetParent === offsetParent.ownerDocument.body;\n    const offsetParentRect = isBody ? {\n        left: 0,\n        top: 0\n    } : offsetParent.getBoundingClientRect();\n    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n    return {\n        x,\n        y\n    };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"px\");\n    return {\n        [(0, _getPrefix.browserPrefixToKey)(\"transform\", _getPrefix.default)]: translation\n    };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {\n    const translation = getTranslation(controlPos, positionOffset, \"\");\n    return translation;\n}\nfunction getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {\n    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;\n    let translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n    if (positionOffset) {\n        const defaultX = \"\".concat(typeof positionOffset.x === \"string\" ? positionOffset.x : positionOffset.x + unitSuffix);\n        const defaultY = \"\".concat(typeof positionOffset.y === \"string\" ? positionOffset.y : positionOffset.y + unitSuffix);\n        translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n    }\n    return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {\n    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {\n    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    let styleEl = doc.getElementById(\"react-draggable-style-el\");\n    if (!styleEl) {\n        styleEl = doc.createElement(\"style\");\n        styleEl.type = \"text/css\";\n        styleEl.id = \"react-draggable-style-el\";\n        styleEl.innerHTML = \".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n\";\n        styleEl.innerHTML += \".react-draggable-transparent-selection *::selection {all: inherit;}\\n\";\n        doc.getElementsByTagName(\"head\")[0].appendChild(styleEl);\n    }\n    if (doc.body) addClassName(doc.body, \"react-draggable-transparent-selection\");\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/ ) {\n    if (!doc) return;\n    try {\n        if (doc.body) removeClassName(doc.body, \"react-draggable-transparent-selection\");\n        // $FlowIgnore: IE\n        if (doc.selection) {\n            // $FlowIgnore: IE\n            doc.selection.empty();\n        } else {\n            // Remove selection caused by scroll, unless it's a focused input\n            // (we use doc.defaultView in case we're in an iframe)\n            const selection = (doc.defaultView || window).getSelection();\n            if (selection && selection.type !== \"Caret\") {\n                selection.removeAllRanges();\n            }\n        }\n    } catch (e) {\n    // probably IE\n    }\n}\nfunction addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else {\n        if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n            el.className += \" \".concat(className);\n        }\n    }\n}\nfunction removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else {\n        el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), \"g\"), \"\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2RvbUZucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUdFO0FBQ3ZCRixnQkFBZ0IsR0FBR0c7QUFDbkJILDJCQUEyQixHQUFHSTtBQUM5QkosMEJBQTBCLEdBQUdLO0FBQzdCTCwwQkFBMEIsR0FBR007QUFDN0JOLGdCQUFnQixHQUFHTztBQUNuQlAsMEJBQTBCLEdBQUdRO0FBQzdCUixzQkFBc0IsR0FBR1M7QUFDekJULG1CQUFtQixHQUFHVTtBQUN0QlYsa0JBQWtCLEdBQUdXO0FBQ3JCWCx1QkFBdUIsR0FBR1k7QUFDMUJaLG1DQUFtQyxHQUFHYTtBQUN0Q2IsMEJBQTBCLEdBQUdjO0FBQzdCZCxtQkFBbUIsR0FBR2U7QUFDdEJmLGtCQUFrQixHQUFHZ0I7QUFDckJoQix1QkFBdUIsR0FBR2lCO0FBQzFCakIsbUJBQW1CLEdBQUdrQjtBQUN0QmxCLDhCQUE4QixHQUFHbUI7QUFDakMsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMscUpBQVM7QUFDOUIsSUFBSUMsYUFBYUMsd0JBQXdCRixtQkFBT0EsQ0FBQyw2SkFBYTtBQUM5RCxTQUFTRyx5QkFBeUJDLFdBQVc7SUFBSSxJQUFJLE9BQU9DLFlBQVksWUFBWSxPQUFPO0lBQU0sSUFBSUMsb0JBQW9CLElBQUlEO0lBQVcsSUFBSUUsbUJBQW1CLElBQUlGO0lBQVcsT0FBTyxDQUFDRiwyQkFBMkIsU0FBVUMsV0FBVztRQUFJLE9BQU9BLGNBQWNHLG1CQUFtQkQ7SUFBbUIsR0FBR0Y7QUFBYztBQUN0VCxTQUFTRix3QkFBd0JNLEdBQUcsRUFBRUosV0FBVztJQUFJLElBQUksQ0FBQ0EsZUFBZUksT0FB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QVg7SUFDdEQsSUFBSTdFLEdBQUc4RSxTQUFTLEVBQUU7UUFDaEI5RSxHQUFHOEUsU0FBUyxDQUFDSSxNQUFNLENBQUNMO0lBQ3RCLE9BQU87UUFDTDdFLEdBQUc2RSxTQUFTLEdBQUc3RSxHQUFHNkUsU0FBUyxDQUFDTSxPQUFPLENBQUMsSUFBSUYsT0FBTyxZQUFZMUIsTUFBTSxDQUFDc0IsV0FBVyxZQUFZLE1BQU07SUFDakc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRyYWdnYWJsZUA0LjQuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9kb21GbnMuanM/YzhjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ2xhc3NOYW1lID0gYWRkQ2xhc3NOYW1lO1xuZXhwb3J0cy5hZGRFdmVudCA9IGFkZEV2ZW50O1xuZXhwb3J0cy5hZGRVc2VyU2VsZWN0U3R5bGVzID0gYWRkVXNlclNlbGVjdFN0eWxlcztcbmV4cG9ydHMuY3JlYXRlQ1NTVHJhbnNmb3JtID0gY3JlYXRlQ1NTVHJhbnNmb3JtO1xuZXhwb3J0cy5jcmVhdGVTVkdUcmFuc2Zvcm0gPSBjcmVhdGVTVkdUcmFuc2Zvcm07XG5leHBvcnRzLmdldFRvdWNoID0gZ2V0VG91Y2g7XG5leHBvcnRzLmdldFRvdWNoSWRlbnRpZmllciA9IGdldFRvdWNoSWRlbnRpZmllcjtcbmV4cG9ydHMuZ2V0VHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbjtcbmV4cG9ydHMuaW5uZXJIZWlnaHQgPSBpbm5lckhlaWdodDtcbmV4cG9ydHMuaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvciA9IG1hdGNoZXNTZWxlY3RvcjtcbmV4cG9ydHMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvID0gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvO1xuZXhwb3J0cy5vZmZzZXRYWUZyb21QYXJlbnQgPSBvZmZzZXRYWUZyb21QYXJlbnQ7XG5leHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5leHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSByZW1vdmVDbGFzc05hbWU7XG5leHBvcnRzLnJlbW92ZUV2ZW50ID0gcmVtb3ZlRXZlbnQ7XG5leHBvcnRzLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMgPSByZW1vdmVVc2VyU2VsZWN0U3R5bGVzO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3NoaW1zXCIpO1xudmFyIF9nZXRQcmVmaXggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9nZXRQcmVmaXhcIikpO1xuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIChub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG4vKjo6IGltcG9ydCB0eXBlIHtDb250cm9sUG9zaXRpb24sIFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG5sZXQgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICcnO1xuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLykgLyo6IGJvb2xlYW4qL3tcbiAgaWYgKCFtYXRjaGVzU2VsZWN0b3JGdW5jKSB7XG4gICAgbWF0Y2hlc1NlbGVjdG9yRnVuYyA9ICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ29NYXRjaGVzU2VsZWN0b3InXSwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICAgICAgcmV0dXJuICgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWV0aG9kXSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBNaWdodCBub3QgYmUgZm91bmQgZW50aXJlbHkgKG5vdCBhbiBFbGVtZW50PykgLSBpbiB0aGF0IGNhc2UsIGJhaWxcbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICBpZiAoISgwLCBfc2hpbXMuaXNGdW5jdGlvbikoZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10pKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gJEZsb3dJZ25vcmU6IERvZXNuJ3QgdGhpbmsgZWxlbWVudHMgYXJlIGluZGV4YWJsZVxuICByZXR1cm4gZWxbbWF0Y2hlc1NlbGVjdG9yRnVuY10oc2VsZWN0b3IpO1xufVxuXG4vLyBXb3JrcyB1cCB0aGUgdHJlZSB0byB0aGUgZHJhZ2dhYmxlIGl0c2VsZiBhdHRlbXB0aW5nIHRvIG1hdGNoIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKGVsIC8qOiBOb2RlKi8sIHNlbGVjdG9yIC8qOiBzdHJpbmcqLywgYmFzZU5vZGUgLyo6IE5vZGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgbGV0IG5vZGUgPSBlbDtcbiAgZG8ge1xuICAgIGlmIChtYXRjaGVzU2VsZWN0b3Iobm9kZSwgc2VsZWN0b3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobm9kZSA9PT0gYmFzZU5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyAkRmxvd0lnbm9yZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gaGFuZGxlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWwgLyo6ID9Ob2RlKi8sIGV2ZW50IC8qOiBzdHJpbmcqLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLywgaW5wdXRPcHRpb25zIC8qOiBPYmplY3QqLykgLyo6IHZvaWQqL3tcbiAgaWYgKCFlbCkgcmV0dXJuO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgLi4uaW5wdXRPcHRpb25zXG4gIH07XG4gIC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICBlbFsnb24nICsgZXZlbnRdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gb3V0ZXJIZWlnaHQobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0VG9wIHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICBoZWlnaHQgKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gb3V0ZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIC8vIFRoaXMgaXMgZGVsaWJlcmF0ZWx5IGV4Y2x1ZGluZyBtYXJnaW4gZm9yIG91ciBjYWxjdWxhdGlvbnMsIHNpbmNlIHdlIGFyZSB1c2luZ1xuICAvLyBvZmZzZXRMZWZ0IHdoaWNoIGlzIGluY2x1ZGluZyBtYXJnaW4uIFNlZSBnZXRCb3VuZFBvc2l0aW9uXG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKTtcbiAgd2lkdGggKz0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCk7XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGlubmVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wKTtcbiAgaGVpZ2h0IC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICByZXR1cm4gaGVpZ2h0O1xufVxuZnVuY3Rpb24gaW5uZXJXaWR0aChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIGxldCB3aWR0aCA9IG5vZGUuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpO1xuICB3aWR0aCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICByZXR1cm4gd2lkdGg7XG59XG4vKjo6IGludGVyZmFjZSBFdmVudFdpdGhPZmZzZXQge1xuICBjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlclxufSovXG4vLyBHZXQgZnJvbSBvZmZzZXRQYXJlbnRcbmZ1bmN0aW9uIG9mZnNldFhZRnJvbVBhcmVudChldnQgLyo6IEV2ZW50V2l0aE9mZnNldCovLCBvZmZzZXRQYXJlbnQgLyo6IEhUTUxFbGVtZW50Ki8sIHNjYWxlIC8qOiBudW1iZXIqLykgLyo6IENvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCBpc0JvZHkgPSBvZmZzZXRQYXJlbnQgPT09IG9mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IG9mZnNldFBhcmVudFJlY3QgPSBpc0JvZHkgPyB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDBcbiAgfSA6IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgeCA9IChldnQuY2xpZW50WCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0IC0gb2Zmc2V0UGFyZW50UmVjdC5sZWZ0KSAvIHNjYWxlO1xuICBjb25zdCB5ID0gKGV2dC5jbGllbnRZICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCAtIG9mZnNldFBhcmVudFJlY3QudG9wKSAvIHNjYWxlO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ1NTVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IE9iamVjdCove1xuICBjb25zdCB0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uKGNvbnRyb2xQb3MsIHBvc2l0aW9uT2Zmc2V0LCAncHgnKTtcbiAgcmV0dXJuIHtcbiAgICBbKDAsIF9nZXRQcmVmaXguYnJvd3NlclByZWZpeFRvS2V5KSgndHJhbnNmb3JtJywgX2dldFByZWZpeC5kZWZhdWx0KV06IHRyYW5zbGF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTVkdUcmFuc2Zvcm0oY29udHJvbFBvcyAvKjogQ29udHJvbFBvc2l0aW9uKi8sIHBvc2l0aW9uT2Zmc2V0IC8qOiBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiovKSAvKjogc3RyaW5nKi97XG4gIGNvbnN0IHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24oY29udHJvbFBvcywgcG9zaXRpb25PZmZzZXQsICcnKTtcbiAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24oX3JlZiAvKjo6ICovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLywgdW5pdFN1ZmZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSAvKjogQ29udHJvbFBvc2l0aW9uKi8gPSBfcmVmIC8qOiBDb250cm9sUG9zaXRpb24qLztcbiAgbGV0IHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHgpLmNvbmNhdCh1bml0U3VmZml4LCBcIixcIikuY29uY2F0KHkpLmNvbmNhdCh1bml0U3VmZml4LCBcIilcIik7XG4gIGlmIChwb3NpdGlvbk9mZnNldCkge1xuICAgIGNvbnN0IGRlZmF1bHRYID0gXCJcIi5jb25jYXQodHlwZW9mIHBvc2l0aW9uT2Zmc2V0LnggPT09ICdzdHJpbmcnID8gcG9zaXRpb25PZmZzZXQueCA6IHBvc2l0aW9uT2Zmc2V0LnggKyB1bml0U3VmZml4KTtcbiAgICBjb25zdCBkZWZhdWx0WSA9IFwiXCIuY29uY2F0KHR5cGVvZiBwb3NpdGlvbk9mZnNldC55ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnkgOiBwb3NpdGlvbk9mZnNldC55ICsgdW5pdFN1ZmZpeCk7XG4gICAgdHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoZGVmYXVsdFgsIFwiLCBcIikuY29uY2F0KGRlZmF1bHRZLCBcIilcIikgKyB0cmFuc2xhdGlvbjtcbiAgfVxuICByZXR1cm4gdHJhbnNsYXRpb247XG59XG5mdW5jdGlvbiBnZXRUb3VjaChlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLywgaWRlbnRpZmllciAvKjogbnVtYmVyKi8pIC8qOiA/e2NsaWVudFg6IG51bWJlciwgY2xpZW50WTogbnVtYmVyfSove1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUudGFyZ2V0VG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpIHx8IGUuY2hhbmdlZFRvdWNoZXMgJiYgKDAsIF9zaGltcy5maW5kSW5BcnJheSkoZS5jaGFuZ2VkVG91Y2hlcywgdCA9PiBpZGVudGlmaWVyID09PSB0LmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovKSAvKjogP251bWJlciove1xuICBpZiAoZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlc1swXSkgcmV0dXJuIGUudGFyZ2V0VG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICBpZiAoZS5jaGFuZ2VkVG91Y2hlcyAmJiBlLmNoYW5nZWRUb3VjaGVzWzBdKSByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xufVxuXG4vLyBVc2VyLXNlbGVjdCBIYWNrczpcbi8vXG4vLyBVc2VmdWwgZm9yIHByZXZlbnRpbmcgYmx1ZSBoaWdobGlnaHRzIGFsbCBvdmVyIGV2ZXJ5dGhpbmcgd2hlbiBkcmFnZ2luZy5cblxuLy8gTm90ZSB3ZSdyZSBwYXNzaW5nIGBkb2N1bWVudGAgYi9jIHdlIGNvdWxkIGJlIGlmcmFtZWRcbmZ1bmN0aW9uIGFkZFVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICBsZXQgc3R5bGVFbCA9IGRvYy5nZXRFbGVtZW50QnlJZCgncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJyk7XG4gIGlmICghc3R5bGVFbCkge1xuICAgIHN0eWxlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIHN0eWxlRWwuaWQgPSAncmVhY3QtZHJhZ2dhYmxlLXN0eWxlLWVsJztcbiAgICBzdHlsZUVsLmlubmVySFRNTCA9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjotbW96LXNlbGVjdGlvbiB7YWxsOiBpbmhlcml0O31cXG4nO1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MICs9ICcucmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge2FsbDogaW5oZXJpdDt9XFxuJztcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgfVxuICBpZiAoZG9jLmJvZHkpIGFkZENsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVzZXJTZWxlY3RTdHlsZXMoZG9jIC8qOiA/RG9jdW1lbnQqLykge1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICB0cnkge1xuICAgIGlmIChkb2MuYm9keSkgcmVtb3ZlQ2xhc3NOYW1lKGRvYy5ib2R5LCAncmVhY3QtZHJhZ2dhYmxlLXRyYW5zcGFyZW50LXNlbGVjdGlvbicpO1xuICAgIC8vICRGbG93SWdub3JlOiBJRVxuICAgIGlmIChkb2Muc2VsZWN0aW9uKSB7XG4gICAgICAvLyAkRmxvd0lnbm9yZTogSUVcbiAgICAgIGRvYy5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBjYXVzZWQgYnkgc2Nyb2xsLCB1bmxlc3MgaXQncyBhIGZvY3VzZWQgaW5wdXRcbiAgICAgIC8vICh3ZSB1c2UgZG9jLmRlZmF1bHRWaWV3IGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lKVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gKGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHlwZSAhPT0gJ0NhcmV0Jykge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcHJvYmFibHkgSUVcbiAgfVxufVxuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUubWF0Y2gobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIikpKSkge1xuICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiLmNvbmNhdChjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lKGVsIC8qOiBIVE1MRWxlbWVudCovLCBjbGFzc05hbWUgLyo6IHN0cmluZyovKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIuY29uY2F0KGNsYXNzTmFtZSwgXCIoPyFcXFxcUylcIiksICdnJyksICcnKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENsYXNzTmFtZSIsImFkZEV2ZW50IiwiYWRkVXNlclNlbGVjdFN0eWxlcyIsImNyZWF0ZUNTU1RyYW5zZm9ybSIsImNyZWF0ZVNWR1RyYW5zZm9ybSIsImdldFRvdWNoIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwiZ2V0VHJhbnNsYXRpb24iLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJtYXRjaGVzU2VsZWN0b3IiLCJtYXRjaGVzU2VsZWN0b3JBbmRQYXJlbnRzVG8iLCJvZmZzZXRYWUZyb21QYXJlbnQiLCJvdXRlckhlaWdodCIsIm91dGVyV2lkdGgiLCJyZW1vdmVDbGFzc05hbWUiLCJyZW1vdmVFdmVudCIsInJlbW92ZVVzZXJTZWxlY3RTdHlsZXMiLCJfc2hpbXMiLCJyZXF1aXJlIiwiX2dldFByZWZpeCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlIiwibm9kZUludGVyb3AiLCJXZWFrTWFwIiwiY2FjaGVCYWJlbEludGVyb3AiLCJjYWNoZU5vZGVJbnRlcm9wIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJjYWNoZSIsImhhcyIsImdldCIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJtYXRjaGVzU2VsZWN0b3JGdW5jIiwiZWwiLCJzZWxlY3RvciIsImZpbmRJbkFycmF5IiwibWV0aG9kIiwiaXNGdW5jdGlvbiIsImJhc2VOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJldmVudCIsImhhbmRsZXIiLCJpbnB1dE9wdGlvbnMiLCJvcHRpb25zIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImNvbXB1dGVkU3R5bGUiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiaW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImV2dCIsIm9mZnNldFBhcmVudCIsInNjYWxlIiwiaXNCb2R5IiwiYm9keSIsIm9mZnNldFBhcmVudFJlY3QiLCJsZWZ0IiwidG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsImNsaWVudFgiLCJzY3JvbGxMZWZ0IiwieSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjb250cm9sUG9zIiwicG9zaXRpb25PZmZzZXQiLCJ0cmFuc2xhdGlvbiIsImJyb3dzZXJQcmVmaXhUb0tleSIsIl9yZWYiLCJ1bml0U3VmZml4IiwiY29uY2F0IiwiZGVmYXVsdFgiLCJkZWZhdWx0WSIsImUiLCJpZGVudGlmaWVyIiwidGFyZ2V0VG91Y2hlcyIsInQiLCJjaGFuZ2VkVG91Y2hlcyIsImRvYyIsInN0eWxlRWwiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiaWQiLCJpbm5lckhUTUwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImFwcGVuZENoaWxkIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJ3aW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJhZGQiLCJtYXRjaCIsIlJlZ0V4cCIsInJlbW92ZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = [\n    \"Moz\",\n    \"Webkit\",\n    \"O\",\n    \"ms\"\n];\nfunction getPrefix() /*: string*/ {\n    var _window$document;\n    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"transform\";\n    // Ensure we're running in an environment where there is actually a global\n    // `window` obj\n    if (true) return \"\";\n    // If we're in a pseudo-browser server-side environment, this access\n    // path may not exist, so bail out if it doesn't.\n    const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;\n    if (!style) return \"\";\n    if (prop in style) return \"\";\n    for(let i = 0; i < prefixes.length; i++){\n        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n    }\n    return \"\";\n}\nfunction browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {\n    return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n}\nfunction kebabToTitleCase(str /*: string*/ ) /*: string*/ {\n    let out = \"\";\n    let shouldCapitalize = true;\n    for(let i = 0; i < str.length; i++){\n        if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n        } else if (str[i] === \"-\") {\n            shouldCapitalize = true;\n        } else {\n            out += str[i];\n        }\n    }\n    return out;\n}\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = getPrefix();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2dldFByZWZpeC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCRiw0QkFBNEIsR0FBR0c7QUFDL0JILGtCQUFlLEdBQUcsS0FBSztBQUN2QkEsaUJBQWlCLEdBQUdLO0FBQ3BCLE1BQU1DLFdBQVc7SUFBQztJQUFPO0lBQVU7SUFBSztDQUFLO0FBQzdDLFNBQVNELFlBQVksVUFBVTtJQUM3QixJQUFJRTtJQUNKLElBQUlDLEtBQUssVUFBVSxNQUFLQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUM1RiwwRUFBMEU7SUFDMUUsZUFBZTtJQUNmLElBQUksSUFBa0IsRUFBYSxPQUFPO0lBRTFDLG9FQUFvRTtJQUNwRSxpREFBaUQ7SUFDakQsTUFBTUcsUUFBUSxDQUFDTCxtQkFBbUJNLE9BQU9DLFFBQVEsTUFBTSxRQUFRUCxxQkFBcUIsS0FBSyxLQUFLLENBQUNBLG1CQUFtQkEsaUJBQWlCUSxlQUFlLE1BQU0sUUFBUVIscUJBQXFCLEtBQUssSUFBSSxLQUFLLElBQUlBLGlCQUFpQkssS0FBSztJQUM3TixJQUFJLENBQUNBLE9BQU8sT0FBTztJQUNuQixJQUFJSixRQUFRSSxPQUFPLE9BQU87SUFDMUIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlWLFNBQVNJLE1BQU0sRUFBRU0sSUFBSztRQUN4QyxJQUFJZCxtQkFBbUJNLE1BQU1GLFFBQVEsQ0FBQ1UsRUFBRSxLQUFLSixPQUFPLE9BQU9OLFFBQVEsQ0FBQ1UsRUFBRTtJQUN4RTtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNkLG1CQUFtQk0sS0FBSyxVQUFVLEdBQVgsRUFBZVMsT0FBTyxVQUFVLEdBQVgsRUFBZSxVQUFVO0lBQzVFLE9BQU9BLFNBQVMsR0FBR0MsTUFBTSxDQUFDRCxRQUFRQyxNQUFNLENBQUNDLGlCQUFpQlgsU0FBU0E7QUFDckU7QUFDQSxTQUFTTCxxQkFBcUJLLEtBQUssVUFBVSxHQUFYLEVBQWVTLE9BQU8sVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUM5RSxPQUFPQSxTQUFTLElBQUlDLE1BQU0sQ0FBQ0QsT0FBT0csV0FBVyxJQUFJLEtBQUtGLE1BQU0sQ0FBQ1YsUUFBUUE7QUFDdkU7QUFDQSxTQUFTVyxpQkFBaUJFLElBQUksVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUNwRCxJQUFJQyxNQUFNO0lBQ1YsSUFBSUMsbUJBQW1CO0lBQ3ZCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJSyxJQUFJWCxNQUFNLEVBQUVNLElBQUs7UUFDbkMsSUFBSU8sa0JBQWtCO1lBQ3BCRCxPQUFPRCxHQUFHLENBQUNMLEVBQUUsQ0FBQ1EsV0FBVztZQUN6QkQsbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSUYsR0FBRyxDQUFDTCxFQUFFLEtBQUssS0FBSztZQUN6Qk8sbUJBQW1CO1FBQ3JCLE9BQU87WUFDTEQsT0FBT0QsR0FBRyxDQUFDTCxFQUFFO1FBQ2Y7SUFDRjtJQUNBLE9BQU9NO0FBQ1Q7QUFFQSxpRUFBaUU7QUFDakUsZ0ZBQWdGO0FBQ2hGLHNFQUFzRTtBQUN0RSxJQUFJRyxXQUFXekIsa0JBQWUsR0FBSUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1kcmFnZ2FibGVANC40LjZfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZ2V0UHJlZml4LmpzP2FiODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb0tleSA9IGJyb3dzZXJQcmVmaXhUb0tleTtcbmV4cG9ydHMuYnJvd3NlclByZWZpeFRvU3R5bGUgPSBicm93c2VyUHJlZml4VG9TdHlsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0UHJlZml4ID0gZ2V0UHJlZml4O1xuY29uc3QgcHJlZml4ZXMgPSBbJ01veicsICdXZWJraXQnLCAnTycsICdtcyddO1xuZnVuY3Rpb24gZ2V0UHJlZml4KCkgLyo6IHN0cmluZyove1xuICB2YXIgX3dpbmRvdyRkb2N1bWVudDtcbiAgbGV0IHByb3AgLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAndHJhbnNmb3JtJztcbiAgLy8gRW5zdXJlIHdlJ3JlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2hlcmUgdGhlcmUgaXMgYWN0dWFsbHkgYSBnbG9iYWxcbiAgLy8gYHdpbmRvd2Agb2JqXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuICcnO1xuXG4gIC8vIElmIHdlJ3JlIGluIGEgcHNldWRvLWJyb3dzZXIgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoaXMgYWNjZXNzXG4gIC8vIHBhdGggbWF5IG5vdCBleGlzdCwgc28gYmFpbCBvdXQgaWYgaXQgZG9lc24ndC5cbiAgY29uc3Qgc3R5bGUgPSAoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgPT09IG51bGwgfHwgX3dpbmRvdyRkb2N1bWVudCA9PT0gdm9pZCAwIHx8IChfd2luZG93JGRvY3VtZW50ID0gX3dpbmRvdyRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID09PSBudWxsIHx8IF93aW5kb3ckZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckZG9jdW1lbnQuc3R5bGU7XG4gIGlmICghc3R5bGUpIHJldHVybiAnJztcbiAgaWYgKHByb3AgaW4gc3R5bGUpIHJldHVybiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChicm93c2VyUHJlZml4VG9LZXkocHJvcCwgcHJlZml4ZXNbaV0pIGluIHN0eWxlKSByZXR1cm4gcHJlZml4ZXNbaV07XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvS2V5KHByb3AgLyo6IHN0cmluZyovLCBwcmVmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIHJldHVybiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChrZWJhYlRvVGl0bGVDYXNlKHByb3ApKSA6IHByb3A7XG59XG5mdW5jdGlvbiBicm93c2VyUHJlZml4VG9TdHlsZShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gcHJlZml4ID8gXCItXCIuY29uY2F0KHByZWZpeC50b0xvd2VyQ2FzZSgpLCBcIi1cIikuY29uY2F0KHByb3ApIDogcHJvcDtcbn1cbmZ1bmN0aW9uIGtlYmFiVG9UaXRsZUNhc2Uoc3RyIC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICBsZXQgb3V0ID0gJyc7XG4gIGxldCBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2hvdWxkQ2FwaXRhbGl6ZSkge1xuICAgICAgb3V0ICs9IHN0cltpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgc2hvdWxkQ2FwaXRhbGl6ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSAnLScpIHtcbiAgICAgIHNob3VsZENhcGl0YWxpemUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gc3RyW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBEZWZhdWx0IGV4cG9ydCBpcyB0aGUgcHJlZml4IGl0c2VsZiwgbGlrZSAnTW96JywgJ1dlYmtpdCcsIGV0Y1xuLy8gTm90ZSB0aGF0IHlvdSBtYXkgaGF2ZSB0byByZS10ZXN0IGZvciBjZXJ0YWluIHRoaW5nczsgZm9yIGluc3RhbmNlLCBDaHJvbWUgNTBcbi8vIGNhbiBoYW5kbGUgdW5wcmVmaXhlZCBgdHJhbnNmb3JtYCwgYnV0IG5vdCB1bnByZWZpeGVkIGB1c2VyLXNlbGVjdGBcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IChnZXRQcmVmaXgoKSAvKjogc3RyaW5nKi8pOyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJyb3dzZXJQcmVmaXhUb0tleSIsImJyb3dzZXJQcmVmaXhUb1N0eWxlIiwiZGVmYXVsdCIsImdldFByZWZpeCIsInByZWZpeGVzIiwiX3dpbmRvdyRkb2N1bWVudCIsInByb3AiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJzdHlsZSIsIndpbmRvdyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaSIsInByZWZpeCIsImNvbmNhdCIsImtlYmFiVG9UaXRsZUNhc2UiLCJ0b0xvd2VyQ2FzZSIsInN0ciIsIm91dCIsInNob3VsZENhcGl0YWxpemUiLCJ0b1VwcGVyQ2FzZSIsIl9kZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/getPrefix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/log.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/log.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/ function log() {\n    if (false) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIscUJBQXFCLEdBQ3JCLFNBQVNBO0lBQ1AsSUFBSUMsS0FBU0EsRUFBRUMsRUFBMEJDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2kvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2xvZy5qcz8yMzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbG9nO1xuLyplc2xpbnQgbm8tY29uc29sZTowKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKHVuZGVmaW5lZCkgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwibG9nIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImFyZ3VtZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/log.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {\n    // If no bounds, short-circuit and move on\n    if (!draggable.props.bounds) return [\n        x,\n        y\n    ];\n    // Clone new bounds\n    let { bounds } = draggable.props;\n    bounds = typeof bounds === \"string\" ? bounds : cloneBounds(bounds);\n    const node = findDOMNode(draggable);\n    if (typeof bounds === \"string\") {\n        const { ownerDocument } = node;\n        const ownerWindow = ownerDocument.defaultView;\n        let boundNode;\n        if (bounds === \"parent\") {\n            boundNode = node.parentNode;\n        } else {\n            boundNode = ownerDocument.querySelector(bounds);\n        }\n        if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n            throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n        }\n        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly\n        const nodeStyle = ownerWindow.getComputedStyle(node);\n        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n        bounds = {\n            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n        };\n    }\n    // Keep x and y below right and bottom limits...\n    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n    // But above left and top limits.\n    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n    return [\n        x,\n        y\n    ];\n}\nfunction snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {\n    const x = Math.round(pendingX / grid[0]) * grid[0];\n    const y = Math.round(pendingY / grid[1]) * grid[1];\n    return [\n        x,\n        y\n    ];\n}\nfunction canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"x\";\n}\nfunction canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {\n    return draggable.props.axis === \"both\" || draggable.props.axis === \"y\";\n}\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {\n    const touchObj = typeof touchIdentifier === \"number\" ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n    if (typeof touchIdentifier === \"number\" && !touchObj) return null; // not the right touch\n    const node = findDOMNode(draggableCore);\n    // User can provide an offsetParent if desired.\n    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {\n    const isStart = !(0, _shims.isNum)(draggable.lastX);\n    const node = findDOMNode(draggable);\n    if (isStart) {\n        // If this is our first move, use the x and y as last coords.\n        return {\n            node,\n            deltaX: 0,\n            deltaY: 0,\n            lastX: x,\n            lastY: y,\n            x,\n            y\n        };\n    } else {\n        // Otherwise calculate proper values.\n        return {\n            node,\n            deltaX: x - draggable.lastX,\n            deltaY: y - draggable.lastY,\n            lastX: draggable.lastX,\n            lastY: draggable.lastY,\n            x,\n            y\n        };\n    }\n}\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {\n    const scale = draggable.props.scale;\n    return {\n        node: coreData.node,\n        x: draggable.state.x + coreData.deltaX / scale,\n        y: draggable.state.y + coreData.deltaY / scale,\n        deltaX: coreData.deltaX / scale,\n        deltaY: coreData.deltaY / scale,\n        lastX: draggable.state.x,\n        lastY: draggable.state.y\n    };\n}\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {\n    return {\n        left: bounds.left,\n        top: bounds.top,\n        right: bounds.right,\n        bottom: bounds.bottom\n    };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {\n    const node = draggable.findDOMNode();\n    if (!node) {\n        throw new Error(\"<DraggableCore>: Unmounted during event!\");\n    }\n    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n    return node;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3Bvc2l0aW9uRm5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxnQkFBZ0IsR0FBR0U7QUFDbkJGLGdCQUFnQixHQUFHRztBQUNuQkgsc0JBQXNCLEdBQUdJO0FBQ3pCSiwyQkFBMkIsR0FBR0s7QUFDOUJMLHdCQUF3QixHQUFHTTtBQUMzQk4sMEJBQTBCLEdBQUdPO0FBQzdCUCxrQkFBa0IsR0FBR1E7QUFDckIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMscUpBQVM7QUFDOUIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUMsdUpBQVU7QUFDaEMsK0NBQStDLEdBQy9DLDBGQUEwRixHQUMxRix1REFBdUQsR0FDdkQsU0FBU0osaUJBQWlCTSxVQUFVLGFBQWEsR0FBZCxFQUFrQkMsRUFBRSxVQUFVLEdBQVgsRUFBZUMsRUFBRSxVQUFVLEdBQVgsRUFBZSxvQkFBb0I7SUFDdkcsMENBQTBDO0lBQzFDLElBQUksQ0FBQ0YsVUFBVUcsS0FBSyxDQUFDQyxNQUFNLEVBQUUsT0FBTztRQUFDSDtRQUFHQztLQUFFO0lBRTFDLG1CQUFtQjtJQUNuQixJQUFJLEVBQ0ZFLE1BQU0sRUFDUCxHQUFHSixVQUFVRyxLQUFLO0lBQ25CQyxTQUFTLE9BQU9BLFdBQVcsV0FBV0EsU0FBU0MsWUFBWUQ7SUFDM0QsTUFBTUUsT0FBT0MsWUFBWVA7SUFDekIsSUFBSSxPQUFPSSxXQUFXLFVBQVU7UUFDOUIsTUFBTSxFQUNKSSxhQUFhLEVBQ2QsR0FBR0Y7UUFDSixNQUFNRyxjQUFjRCxjQUFjRSxXQUFXO1FBQzdDLElBQUlDO1FBQ0osSUFBSVAsV0FBVyxVQUFVO1lBQ3ZCTyxZQUFZTCxLQUFLTSxV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LE1BQU0sSUFBSVMsTUFBTTtJQUNsQjtJQUNBLG1FQUFtRTtJQUNuRSxPQUFPVDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2kvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3Bvc2l0aW9uRm5zLmpzPzU5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbkRyYWdYID0gY2FuRHJhZ1g7XG5leHBvcnRzLmNhbkRyYWdZID0gY2FuRHJhZ1k7XG5leHBvcnRzLmNyZWF0ZUNvcmVEYXRhID0gY3JlYXRlQ29yZURhdGE7XG5leHBvcnRzLmNyZWF0ZURyYWdnYWJsZURhdGEgPSBjcmVhdGVEcmFnZ2FibGVEYXRhO1xuZXhwb3J0cy5nZXRCb3VuZFBvc2l0aW9uID0gZ2V0Qm91bmRQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0Q29udHJvbFBvc2l0aW9uID0gZ2V0Q29udHJvbFBvc2l0aW9uO1xuZXhwb3J0cy5zbmFwVG9HcmlkID0gc25hcFRvR3JpZDtcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vZG9tRm5zXCIpO1xuLyo6OiBpbXBvcnQgdHlwZSBEcmFnZ2FibGUgZnJvbSAnLi4vRHJhZ2dhYmxlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZURhdGEsIE1vdXNlVG91Y2hFdmVudH0gZnJvbSAnLi90eXBlcyc7Ki9cbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZSBmcm9tICcuLi9EcmFnZ2FibGVDb3JlJzsqL1xuZnVuY3Rpb24gZ2V0Qm91bmRQb3NpdGlvbihkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIC8vIElmIG5vIGJvdW5kcywgc2hvcnQtY2lyY3VpdCBhbmQgbW92ZSBvblxuICBpZiAoIWRyYWdnYWJsZS5wcm9wcy5ib3VuZHMpIHJldHVybiBbeCwgeV07XG5cbiAgLy8gQ2xvbmUgbmV3IGJvdW5kc1xuICBsZXQge1xuICAgIGJvdW5kc1xuICB9ID0gZHJhZ2dhYmxlLnByb3BzO1xuICBib3VuZHMgPSB0eXBlb2YgYm91bmRzID09PSAnc3RyaW5nJyA/IGJvdW5kcyA6IGNsb25lQm91bmRzKGJvdW5kcyk7XG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGUpO1xuICBpZiAodHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgb3duZXJXaW5kb3cgPSBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGxldCBib3VuZE5vZGU7XG4gICAgaWYgKGJvdW5kcyA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIGJvdW5kTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmROb2RlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJvdW5kcyk7XG4gICAgfVxuICAgIGlmICghKGJvdW5kTm9kZSBpbnN0YW5jZW9mIG93bmVyV2luZG93LkhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZHMgc2VsZWN0b3IgXCInICsgYm91bmRzICsgJ1wiIGNvdWxkIG5vdCBmaW5kIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kTm9kZUVsIC8qOiBIVE1MRWxlbWVudCovID0gYm91bmROb2RlOyAvLyBmb3IgRmxvdywgY2FuJ3Qgc2VlbSB0byByZWZpbmUgY29ycmVjdGx5XG4gICAgY29uc3Qgbm9kZVN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBib3VuZE5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoYm91bmROb2RlRWwpO1xuICAgIC8vIENvbXB1dGUgYm91bmRzLiBUaGlzIGlzIGEgcGFpbiB3aXRoIHBhZGRpbmcgYW5kIG9mZnNldHMgYnV0IHRoaXMgZ2V0cyBpdCBleGFjdGx5IHJpZ2h0LlxuICAgIGJvdW5kcyA9IHtcbiAgICAgIGxlZnQ6IC1ub2RlLm9mZnNldExlZnQgKyAoMCwgX3NoaW1zLmludCkoYm91bmROb2RlU3R5bGUucGFkZGluZ0xlZnQpICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5MZWZ0KSxcbiAgICAgIHRvcDogLW5vZGUub2Zmc2V0VG9wICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdUb3ApICsgKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5Ub3ApLFxuICAgICAgcmlnaHQ6ICgwLCBfZG9tRm5zLmlubmVyV2lkdGgpKGJvdW5kTm9kZUVsKSAtICgwLCBfZG9tRm5zLm91dGVyV2lkdGgpKG5vZGUpIC0gbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdSaWdodCkgLSAoMCwgX3NoaW1zLmludCkobm9kZVN0eWxlLm1hcmdpblJpZ2h0KSxcbiAgICAgIGJvdHRvbTogKDAsIF9kb21GbnMuaW5uZXJIZWlnaHQpKGJvdW5kTm9kZUVsKSAtICgwLCBfZG9tRm5zLm91dGVySGVpZ2h0KShub2RlKSAtIG5vZGUub2Zmc2V0VG9wICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20pIC0gKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5Cb3R0b20pXG4gICAgfTtcbiAgfVxuXG4gIC8vIEtlZXAgeCBhbmQgeSBiZWxvdyByaWdodCBhbmQgYm90dG9tIGxpbWl0cy4uLlxuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLnJpZ2h0KSkgeCA9IE1hdGgubWluKHgsIGJvdW5kcy5yaWdodCk7XG4gIGlmICgoMCwgX3NoaW1zLmlzTnVtKShib3VuZHMuYm90dG9tKSkgeSA9IE1hdGgubWluKHksIGJvdW5kcy5ib3R0b20pO1xuXG4gIC8vIEJ1dCBhYm92ZSBsZWZ0IGFuZCB0b3AgbGltaXRzLlxuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmxlZnQpKSB4ID0gTWF0aC5tYXgoeCwgYm91bmRzLmxlZnQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLnRvcCkpIHkgPSBNYXRoLm1heCh5LCBib3VuZHMudG9wKTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIHNuYXBUb0dyaWQoZ3JpZCAvKjogW251bWJlciwgbnVtYmVyXSovLCBwZW5kaW5nWCAvKjogbnVtYmVyKi8sIHBlbmRpbmdZIC8qOiBudW1iZXIqLykgLyo6IFtudW1iZXIsIG51bWJlcl0qL3tcbiAgY29uc3QgeCA9IE1hdGgucm91bmQocGVuZGluZ1ggLyBncmlkWzBdKSAqIGdyaWRbMF07XG4gIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHBlbmRpbmdZIC8gZ3JpZFsxXSkgKiBncmlkWzFdO1xuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gY2FuRHJhZ1goZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuIGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICd4Jztcbn1cbmZ1bmN0aW9uIGNhbkRyYWdZKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneSc7XG59XG5cbi8vIEdldCB7eCwgeX0gcG9zaXRpb25zIGZyb20gZXZlbnQuXG5mdW5jdGlvbiBnZXRDb250cm9sUG9zaXRpb24oZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8sIHRvdWNoSWRlbnRpZmllciAvKjogP251bWJlciovLCBkcmFnZ2FibGVDb3JlIC8qOiBEcmFnZ2FibGVDb3JlKi8pIC8qOiA/Q29udHJvbFBvc2l0aW9uKi97XG4gIGNvbnN0IHRvdWNoT2JqID0gdHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgPyAoMCwgX2RvbUZucy5nZXRUb3VjaCkoZSwgdG91Y2hJZGVudGlmaWVyKSA6IG51bGw7XG4gIGlmICh0eXBlb2YgdG91Y2hJZGVudGlmaWVyID09PSAnbnVtYmVyJyAmJiAhdG91Y2hPYmopIHJldHVybiBudWxsOyAvLyBub3QgdGhlIHJpZ2h0IHRvdWNoXG4gIGNvbnN0IG5vZGUgPSBmaW5kRE9NTm9kZShkcmFnZ2FibGVDb3JlKTtcbiAgLy8gVXNlciBjYW4gcHJvdmlkZSBhbiBvZmZzZXRQYXJlbnQgaWYgZGVzaXJlZC5cbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gZHJhZ2dhYmxlQ29yZS5wcm9wcy5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vZmZzZXRQYXJlbnQgfHwgbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIHJldHVybiAoMCwgX2RvbUZucy5vZmZzZXRYWUZyb21QYXJlbnQpKHRvdWNoT2JqIHx8IGUsIG9mZnNldFBhcmVudCwgZHJhZ2dhYmxlQ29yZS5wcm9wcy5zY2FsZSk7XG59XG5cbi8vIENyZWF0ZSBhbiBkYXRhIG9iamVjdCBleHBvc2VkIGJ5IDxEcmFnZ2FibGVDb3JlPidzIGV2ZW50c1xuZnVuY3Rpb24gY3JlYXRlQ29yZURhdGEoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGVDb3JlKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLykgLyo6IERyYWdnYWJsZURhdGEqL3tcbiAgY29uc3QgaXNTdGFydCA9ICEoMCwgX3NoaW1zLmlzTnVtKShkcmFnZ2FibGUubGFzdFgpO1xuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcbiAgaWYgKGlzU3RhcnQpIHtcbiAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBtb3ZlLCB1c2UgdGhlIHggYW5kIHkgYXMgbGFzdCBjb29yZHMuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICBkZWx0YVg6IDAsXG4gICAgICBkZWx0YVk6IDAsXG4gICAgICBsYXN0WDogeCxcbiAgICAgIGxhc3RZOiB5LFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcHJvcGVyIHZhbHVlcy5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZSxcbiAgICAgIGRlbHRhWDogeCAtIGRyYWdnYWJsZS5sYXN0WCxcbiAgICAgIGRlbHRhWTogeSAtIGRyYWdnYWJsZS5sYXN0WSxcbiAgICAgIGxhc3RYOiBkcmFnZ2FibGUubGFzdFgsXG4gICAgICBsYXN0WTogZHJhZ2dhYmxlLmxhc3RZLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59XG5cbi8vIENyZWF0ZSBhbiBkYXRhIGV4cG9zZWQgYnkgPERyYWdnYWJsZT4ncyBldmVudHNcbmZ1bmN0aW9uIGNyZWF0ZURyYWdnYWJsZURhdGEoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLywgY29yZURhdGEgLyo6IERyYWdnYWJsZURhdGEqLykgLyo6IERyYWdnYWJsZURhdGEqL3tcbiAgY29uc3Qgc2NhbGUgPSBkcmFnZ2FibGUucHJvcHMuc2NhbGU7XG4gIHJldHVybiB7XG4gICAgbm9kZTogY29yZURhdGEubm9kZSxcbiAgICB4OiBkcmFnZ2FibGUuc3RhdGUueCArIGNvcmVEYXRhLmRlbHRhWCAvIHNjYWxlLFxuICAgIHk6IGRyYWdnYWJsZS5zdGF0ZS55ICsgY29yZURhdGEuZGVsdGFZIC8gc2NhbGUsXG4gICAgZGVsdGFYOiBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICBkZWx0YVk6IGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGxhc3RYOiBkcmFnZ2FibGUuc3RhdGUueCxcbiAgICBsYXN0WTogZHJhZ2dhYmxlLnN0YXRlLnlcbiAgfTtcbn1cblxuLy8gQSBsb3QgZmFzdGVyIHRoYW4gc3RyaW5naWZ5L3BhcnNlXG5mdW5jdGlvbiBjbG9uZUJvdW5kcyhib3VuZHMgLyo6IEJvdW5kcyovKSAvKjogQm91bmRzKi97XG4gIHJldHVybiB7XG4gICAgbGVmdDogYm91bmRzLmxlZnQsXG4gICAgdG9wOiBib3VuZHMudG9wLFxuICAgIHJpZ2h0OiBib3VuZHMucmlnaHQsXG4gICAgYm90dG9tOiBib3VuZHMuYm90dG9tXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kRE9NTm9kZShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSB8IERyYWdnYWJsZUNvcmUqLykgLyo6IEhUTUxFbGVtZW50Ki97XG4gIGNvbnN0IG5vZGUgPSBkcmFnZ2FibGUuZmluZERPTU5vZGUoKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8RHJhZ2dhYmxlQ29yZT46IFVubW91bnRlZCBkdXJpbmcgZXZlbnQhJyk7XG4gIH1cbiAgLy8gJEZsb3dJZ25vcmUgd2UgY2FuJ3QgYXNzZXJ0IG9uIEhUTUxFbGVtZW50IGR1ZSB0byB0ZXN0cy4uLiBGSVhNRVxuICByZXR1cm4gbm9kZTtcbn0iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYW5EcmFnWCIsImNhbkRyYWdZIiwiY3JlYXRlQ29yZURhdGEiLCJjcmVhdGVEcmFnZ2FibGVEYXRhIiwiZ2V0Qm91bmRQb3NpdGlvbiIsImdldENvbnRyb2xQb3NpdGlvbiIsInNuYXBUb0dyaWQiLCJfc2hpbXMiLCJyZXF1aXJlIiwiX2RvbUZucyIsImRyYWdnYWJsZSIsIngiLCJ5IiwicHJvcHMiLCJib3VuZHMiLCJjbG9uZUJvdW5kcyIsIm5vZGUiLCJmaW5kRE9NTm9kZSIsIm93bmVyRG9jdW1lbnQiLCJvd25lcldpbmRvdyIsImRlZmF1bHRWaWV3IiwiYm91bmROb2RlIiwicGFyZW50Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIkVycm9yIiwiYm91bmROb2RlRWwiLCJub2RlU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiYm91bmROb2RlU3R5bGUiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsImludCIsInBhZGRpbmdMZWZ0IiwibWFyZ2luTGVmdCIsInRvcCIsIm9mZnNldFRvcCIsInBhZGRpbmdUb3AiLCJtYXJnaW5Ub3AiLCJyaWdodCIsImlubmVyV2lkdGgiLCJvdXRlcldpZHRoIiwicGFkZGluZ1JpZ2h0IiwibWFyZ2luUmlnaHQiLCJib3R0b20iLCJpbm5lckhlaWdodCIsIm91dGVySGVpZ2h0IiwicGFkZGluZ0JvdHRvbSIsIm1hcmdpbkJvdHRvbSIsImlzTnVtIiwiTWF0aCIsIm1pbiIsIm1heCIsImdyaWQiLCJwZW5kaW5nWCIsInBlbmRpbmdZIiwicm91bmQiLCJheGlzIiwiZSIsInRvdWNoSWRlbnRpZmllciIsImRyYWdnYWJsZUNvcmUiLCJ0b3VjaE9iaiIsImdldFRvdWNoIiwib2Zmc2V0UGFyZW50IiwiYm9keSIsIm9mZnNldFhZRnJvbVBhcmVudCIsInNjYWxlIiwiaXNTdGFydCIsImxhc3RYIiwiZGVsdGFYIiwiZGVsdGFZIiwibGFzdFkiLCJjb3JlRGF0YSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/positionFns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {\n    for(let i = 0, length = array.length; i < length; i++){\n        if (callback.apply(callback, [\n            array[i],\n            i,\n            array\n        ])) return array[i];\n    }\n}\nfunction isFunction(func /*: any*/ ) /*: boolean %checks*/ {\n    // $FlowIgnore[method-unbinding]\n    return typeof func === \"function\" || Object.prototype.toString.call(func) === \"[object Function]\";\n}\nfunction isNum(num /*: any*/ ) /*: boolean %checks*/ {\n    return typeof num === \"number\" && !isNaN(num);\n}\nfunction int(a /*: string*/ ) /*: number*/ {\n    return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {\n    if (props[propName]) {\n        return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWJBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGRCxpQkFBaUIsR0FBR0U7QUFDcEJGLG1CQUFtQixHQUFHRztBQUN0QkgsV0FBVyxHQUFHSTtBQUNkSixrQkFBa0IsR0FBR0s7QUFDckJMLGFBQWEsR0FBR007QUFDaEIscUVBQXFFO0FBQ3JFLFNBQVNILFlBQVlJLE1BQU0sMEJBQTBCLEdBQTNCLEVBQStCQyxTQUFTLFlBQVksR0FBYixFQUFpQixPQUFPO0lBQ3ZGLElBQUssSUFBSUMsSUFBSSxHQUFHQyxTQUFTSCxNQUFNRyxNQUFNLEVBQUVELElBQUlDLFFBQVFELElBQUs7UUFDdEQsSUFBSUQsU0FBU0csS0FBSyxDQUFDSCxVQUFVO1lBQUNELEtBQUssQ0FBQ0UsRUFBRTtZQUFFQTtZQUFHRjtTQUFNLEdBQUcsT0FBT0EsS0FBSyxDQUFDRSxFQUFFO0lBQ3JFO0FBQ0Y7QUFDQSxTQUFTSixXQUFXTyxLQUFLLE9BQU8sR0FBUixFQUFZLG1CQUFtQjtJQUNyRCxnQ0FBZ0M7SUFDaEMsT0FBTyxPQUFPQSxTQUFTLGNBQWNkLE9BQU9lLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNILFVBQVU7QUFDaEY7QUFDQSxTQUFTTixNQUFNVSxJQUFJLE9BQU8sR0FBUixFQUFZLG1CQUFtQjtJQUMvQyxPQUFPLE9BQU9BLFFBQVEsWUFBWSxDQUFDQyxNQUFNRDtBQUMzQztBQUNBLFNBQVNaLElBQUljLEVBQUUsVUFBVSxHQUFYLEVBQWUsVUFBVTtJQUNyQyxPQUFPQyxTQUFTRCxHQUFHO0FBQ3JCO0FBQ0EsU0FBU2hCLFVBQVVrQixNQUFNLFVBQVUsR0FBWCxFQUFlQyxTQUFTLFVBQVUsR0FBWCxFQUFlQyxjQUFjLFVBQVUsR0FBWCxFQUFlLFVBQVU7SUFDbEcsSUFBSUYsS0FBSyxDQUFDQyxTQUFTLEVBQUU7UUFDbkIsT0FBTyxJQUFJRSxNQUFNLGdCQUFnQkMsTUFBTSxDQUFDSCxVQUFVLGVBQWVHLE1BQU0sQ0FBQ0YsZUFBZTtJQUN6RjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2kvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZHJhZ2dhYmxlQDQuNC42X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzP2IxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcbmV4cG9ydHMuZmluZEluQXJyYXkgPSBmaW5kSW5BcnJheTtcbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdW0gPSBpc051bTtcbi8vIEBjcmVkaXRzIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JvZ296aG5pa29mZi9hNDNjZmVkMjdjNDFlNGU2OGNkY1xuZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBbYXJyYXlbaV0sIGksIGFycmF5XSkpIHJldHVybiBhcnJheVtpXTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmMpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNOdW0obnVtIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG59XG5mdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqL3tcbiAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcbn1cbmZ1bmN0aW9uIGRvbnRTZXRNZShwcm9wcyAvKjogT2JqZWN0Ki8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLywgY29tcG9uZW50TmFtZSAvKjogc3RyaW5nKi8pIC8qOiA/RXJyb3IqL3tcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgXCIuY29uY2F0KHByb3BOYW1lLCBcIiBwYXNzZWQgdG8gXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiAtIGRvIG5vdCBzZXQgdGhpcywgc2V0IGl0IG9uIHRoZSBjaGlsZC5cIikpO1xuICB9XG59Il0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZG9udFNldE1lIiwiZmluZEluQXJyYXkiLCJpbnQiLCJpc0Z1bmN0aW9uIiwiaXNOdW0iLCJhcnJheSIsImNhbGxiYWNrIiwiaSIsImxlbmd0aCIsImFwcGx5IiwiZnVuYyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm51bSIsImlzTmFOIiwiYSIsInBhcnNlSW50IiwicHJvcHMiLCJwcm9wTmFtZSIsImNvbXBvbmVudE5hbWUiLCJFcnJvciIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-draggable@4.4.6_react-dom@18.2.0_react@18.2.0/node_modules/react-draggable/build/cjs/utils/shims.js\n");

/***/ })

};
;